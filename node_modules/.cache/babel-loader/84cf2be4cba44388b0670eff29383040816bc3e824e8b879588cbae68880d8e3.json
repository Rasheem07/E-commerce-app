{"ast":null,"code":"import _defineProperty from \"C:/Users/LENOVO/OneDrive/E-com site/app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _inherits from \"C:/Users/LENOVO/OneDrive/E-com site/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/LENOVO/OneDrive/E-com site/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _toConsumableArray from \"C:/Users/LENOVO/OneDrive/E-com site/app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/LENOVO/OneDrive/E-com site/app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/LENOVO/OneDrive/E-com site/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/LENOVO/OneDrive/E-com site/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\r\n * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)\r\n *\r\n * Copyright (c) 2022 Kiro Risk (http://kiro.me)\r\n * All Rights Reserved. Apache Software License 2.0\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n */\n\nfunction isArray(value) {\n  return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nvar INFINITY = 1 / 0;\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  var result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n  return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';\n}\nfunction isObject(value) {\n  return typeof value === 'object';\n}\n\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null;\n}\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\nfunction isBlank(value) {\n  return !value.trim().length;\n}\n\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n  return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);\n}\nvar EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\nvar INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\nvar LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key) {\n  return \"Invalid value for key \".concat(key);\n};\nvar PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE(max) {\n  return \"Pattern length exceeds max of \".concat(max, \".\");\n};\nvar MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY(name) {\n  return \"Missing \".concat(name, \" property in key\");\n};\nvar INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE(key) {\n  return \"Property 'weight' in key '\".concat(key, \"' must be a positive integer\");\n};\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar KeyStore = /*#__PURE__*/function () {\n  function KeyStore(keys) {\n    var _this = this;\n    _classCallCheck(this, KeyStore);\n    this._keys = [];\n    this._keyMap = {};\n    var totalWeight = 0;\n    keys.forEach(function (key) {\n      var obj = createKey(key);\n      totalWeight += obj.weight;\n      _this._keys.push(obj);\n      _this._keyMap[obj.id] = obj;\n      totalWeight += obj.weight;\n    });\n\n    // Normalize weights so that their sum is equal to 1\n    this._keys.forEach(function (key) {\n      key.weight /= totalWeight;\n    });\n  }\n  _createClass(KeyStore, [{\n    key: \"get\",\n    value: function get(keyId) {\n      return this._keyMap[keyId];\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return this._keys;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return JSON.stringify(this._keys);\n    }\n  }]);\n  return KeyStore;\n}();\nfunction createKey(key) {\n  var path = null;\n  var id = null;\n  var src = null;\n  var weight = 1;\n  var getFn = null;\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, 'name')) {\n      throw new Error(MISSING_KEY_PROPERTY('name'));\n    }\n    var name = key.name;\n    src = name;\n    if (hasOwn.call(key, 'weight')) {\n      weight = key.weight;\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));\n      }\n    }\n    path = createKeyPath(name);\n    id = createKeyId(name);\n    getFn = key.getFn;\n  }\n  return {\n    path: path,\n    id: id,\n    weight: weight,\n    src: src,\n    getFn: getFn\n  };\n}\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split('.');\n}\nfunction createKeyId(key) {\n  return isArray(key) ? key.join('.') : key;\n}\nfunction get(obj, path) {\n  var list = [];\n  var arr = false;\n  var deepGet = function deepGet(obj, path, index) {\n    if (!isDefined(obj)) {\n      return;\n    }\n    if (!path[index]) {\n      // If there's no path left, we've arrived at the object we care about.\n      list.push(obj);\n    } else {\n      var key = path[index];\n      var value = obj[key];\n      if (!isDefined(value)) {\n        return;\n      }\n\n      // If we're at the last value in the path, and if it's a string/number/bool,\n      // add it to the list\n      if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path, index + 1);\n        }\n      } else if (path.length) {\n        // An object. Recurse further.\n        deepGet(value, path, index + 1);\n      }\n    }\n  };\n\n  // Backwards compatibility (since path used to be a string)\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\n  return arr ? list : list[0];\n}\nvar MatchOptions = {\n  // Whether the matches should be included in the result set. When `true`, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When `true`, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\nvar BasicOptions = {\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function: sort by ascending score, ascending index\n  sortFn: function sortFn(a, b) {\n    return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;\n  }\n};\nvar FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\nvar AdvancedOptions = {\n  // When `true`, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\n  // where in the string the pattern appears.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n  ignoreLocation: false,\n  // When `true`, the calculation for the relevance score (used for sorting) will\n  // ignore the field-length norm.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n  ignoreFieldNorm: false,\n  // The weight to determine how much field length norm effects scoring.\n  fieldNormWeight: 1\n};\nvar Config = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);\nvar SPACE = /[^ ]+/g;\n\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm() {\n  var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var mantissa = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var cache = new Map();\n  var m = Math.pow(10, mantissa);\n  return {\n    get: function get(value) {\n      var numTokens = value.match(SPACE).length;\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens);\n      }\n\n      // Default function is 1/sqrt(x), weight makes that variable\n      var norm = 1 / Math.pow(numTokens, 0.5 * weight);\n\n      // In place of `toFixed(mantissa)`, for faster computation\n      var n = parseFloat(Math.round(norm * m) / m);\n      cache.set(numTokens, n);\n      return n;\n    },\n    clear: function clear() {\n      cache.clear();\n    }\n  };\n}\nvar FuseIndex = /*#__PURE__*/function () {\n  function FuseIndex() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$getFn = _ref.getFn,\n      getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn,\n      _ref$fieldNormWeight = _ref.fieldNormWeight,\n      fieldNormWeight = _ref$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref$fieldNormWeight;\n    _classCallCheck(this, FuseIndex);\n    this.norm = norm(fieldNormWeight, 3);\n    this.getFn = getFn;\n    this.isCreated = false;\n    this.setIndexRecords();\n  }\n  _createClass(FuseIndex, [{\n    key: \"setSources\",\n    value: function setSources() {\n      var docs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.docs = docs;\n    }\n  }, {\n    key: \"setIndexRecords\",\n    value: function setIndexRecords() {\n      var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.records = records;\n    }\n  }, {\n    key: \"setKeys\",\n    value: function setKeys() {\n      var _this2 = this;\n      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.keys = keys;\n      this._keysMap = {};\n      keys.forEach(function (key, idx) {\n        _this2._keysMap[key.id] = idx;\n      });\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      var _this3 = this;\n      if (this.isCreated || !this.docs.length) {\n        return;\n      }\n      this.isCreated = true;\n\n      // List is Array<String>\n      if (isString(this.docs[0])) {\n        this.docs.forEach(function (doc, docIndex) {\n          _this3._addString(doc, docIndex);\n        });\n      } else {\n        // List is Array<Object>\n        this.docs.forEach(function (doc, docIndex) {\n          _this3._addObject(doc, docIndex);\n        });\n      }\n      this.norm.clear();\n    }\n    // Adds a doc to the end of the index\n  }, {\n    key: \"add\",\n    value: function add(doc) {\n      var idx = this.size();\n      if (isString(doc)) {\n        this._addString(doc, idx);\n      } else {\n        this._addObject(doc, idx);\n      }\n    }\n    // Removes the doc at the specified index of the index\n  }, {\n    key: \"removeAt\",\n    value: function removeAt(idx) {\n      this.records.splice(idx, 1);\n\n      // Change ref index of every subsquent doc\n      for (var i = idx, len = this.size(); i < len; i += 1) {\n        this.records[i].i -= 1;\n      }\n    }\n  }, {\n    key: \"getValueForItemAtKeyId\",\n    value: function getValueForItemAtKeyId(item, keyId) {\n      return item[this._keysMap[keyId]];\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.records.length;\n    }\n  }, {\n    key: \"_addString\",\n    value: function _addString(doc, docIndex) {\n      if (!isDefined(doc) || isBlank(doc)) {\n        return;\n      }\n      var record = {\n        v: doc,\n        i: docIndex,\n        n: this.norm.get(doc)\n      };\n      this.records.push(record);\n    }\n  }, {\n    key: \"_addObject\",\n    value: function _addObject(doc, docIndex) {\n      var _this4 = this;\n      var record = {\n        i: docIndex,\n        $: {}\n      };\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      this.keys.forEach(function (key, keyIndex) {\n        var value = key.getFn ? key.getFn(doc) : _this4.getFn(doc, key.path);\n        if (!isDefined(value)) {\n          return;\n        }\n        if (isArray(value)) {\n          var subRecords = [];\n          var stack = [{\n            nestedArrIndex: -1,\n            value: value\n          }];\n          while (stack.length) {\n            var _stack$pop = stack.pop(),\n              nestedArrIndex = _stack$pop.nestedArrIndex,\n              _value = _stack$pop.value;\n            if (!isDefined(_value)) {\n              continue;\n            }\n            if (isString(_value) && !isBlank(_value)) {\n              var subRecord = {\n                v: _value,\n                i: nestedArrIndex,\n                n: _this4.norm.get(_value)\n              };\n              subRecords.push(subRecord);\n            } else if (isArray(_value)) {\n              _value.forEach(function (item, k) {\n                stack.push({\n                  nestedArrIndex: k,\n                  value: item\n                });\n              });\n            } else ;\n          }\n          record.$[keyIndex] = subRecords;\n        } else if (isString(value) && !isBlank(value)) {\n          var _subRecord = {\n            v: value,\n            n: _this4.norm.get(value)\n          };\n          record.$[keyIndex] = _subRecord;\n        }\n      });\n      this.records.push(record);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        keys: this.keys,\n        records: this.records\n      };\n    }\n  }]);\n  return FuseIndex;\n}();\nfunction createIndex(keys, docs) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$getFn = _ref2.getFn,\n    getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn,\n    _ref2$fieldNormWeight = _ref2.fieldNormWeight,\n    fieldNormWeight = _ref2$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref2$fieldNormWeight;\n  var myIndex = new FuseIndex({\n    getFn: getFn,\n    fieldNormWeight: fieldNormWeight\n  });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex;\n}\nfunction parseIndex(data) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref3$getFn = _ref3.getFn,\n    getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn,\n    _ref3$fieldNormWeight = _ref3.fieldNormWeight,\n    fieldNormWeight = _ref3$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref3$fieldNormWeight;\n  var keys = data.keys,\n    records = data.records;\n  var myIndex = new FuseIndex({\n    getFn: getFn,\n    fieldNormWeight: fieldNormWeight\n  });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex;\n}\nfunction computeScore$1(pattern) {\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref4$errors = _ref4.errors,\n    errors = _ref4$errors === void 0 ? 0 : _ref4$errors,\n    _ref4$currentLocation = _ref4.currentLocation,\n    currentLocation = _ref4$currentLocation === void 0 ? 0 : _ref4$currentLocation,\n    _ref4$expectedLocatio = _ref4.expectedLocation,\n    expectedLocation = _ref4$expectedLocatio === void 0 ? 0 : _ref4$expectedLocatio,\n    _ref4$distance = _ref4.distance,\n    distance = _ref4$distance === void 0 ? Config.distance : _ref4$distance,\n    _ref4$ignoreLocation = _ref4.ignoreLocation,\n    ignoreLocation = _ref4$ignoreLocation === void 0 ? Config.ignoreLocation : _ref4$ignoreLocation;\n  var accuracy = errors / pattern.length;\n  if (ignoreLocation) {\n    return accuracy;\n  }\n  var proximity = Math.abs(expectedLocation - currentLocation);\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n  return accuracy + proximity / distance;\n}\nfunction convertMaskToIndices() {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Config.minMatchCharLength;\n  var indices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n  return indices;\n}\n\n// Machine word size\nvar MAX_BITS = 32;\nfunction search(text, pattern, patternAlphabet) {\n  var _ref5 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    _ref5$location = _ref5.location,\n    location = _ref5$location === void 0 ? Config.location : _ref5$location,\n    _ref5$distance = _ref5.distance,\n    distance = _ref5$distance === void 0 ? Config.distance : _ref5$distance,\n    _ref5$threshold = _ref5.threshold,\n    threshold = _ref5$threshold === void 0 ? Config.threshold : _ref5$threshold,\n    _ref5$findAllMatches = _ref5.findAllMatches,\n    findAllMatches = _ref5$findAllMatches === void 0 ? Config.findAllMatches : _ref5$findAllMatches,\n    _ref5$minMatchCharLen = _ref5.minMatchCharLength,\n    minMatchCharLength = _ref5$minMatchCharLen === void 0 ? Config.minMatchCharLength : _ref5$minMatchCharLen,\n    _ref5$includeMatches = _ref5.includeMatches,\n    includeMatches = _ref5$includeMatches === void 0 ? Config.includeMatches : _ref5$includeMatches,\n    _ref5$ignoreLocation = _ref5.ignoreLocation,\n    ignoreLocation = _ref5$ignoreLocation === void 0 ? Config.ignoreLocation : _ref5$ignoreLocation;\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\n  }\n  var patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  var textLen = text.length;\n  // Handle the case when location > text.length\n  var expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  var currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  var bestLocation = expectedLocation;\n\n  // Performance: only computer matches when the minMatchCharLength > 1\n  // OR if `includeMatches` is true.\n  var computeMatches = minMatchCharLength > 1 || includeMatches;\n  // A mask of the matches, used for building the indices\n  var matchMask = computeMatches ? Array(textLen) : [];\n  var index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    var score = computeScore$1(pattern, {\n      currentLocation: index,\n      expectedLocation: expectedLocation,\n      distance: distance,\n      ignoreLocation: ignoreLocation\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n    if (computeMatches) {\n      var i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n  var mask = 1 << patternLen - 1;\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n    while (binMin < binMid) {\n      var _score = computeScore$1(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance,\n        ignoreLocation: ignoreLocation\n      });\n      if (_score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    var bitArr = Array(finish + 2);\n    bitArr[finish + 1] = (1 << _i) - 1;\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n      if (computeMatches) {\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      // First pass: exact match\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (_i) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n      if (bitArr[j] & mask) {\n        finalScore = computeScore$1(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance,\n          ignoreLocation: ignoreLocation\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    var _score2 = computeScore$1(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance,\n      ignoreLocation: ignoreLocation\n    });\n    if (_score2 > currentThreshold) {\n      break;\n    }\n    lastBitArr = bitArr;\n  }\n  var result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: Math.max(0.001, finalScore)\n  };\n  if (computeMatches) {\n    var indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n  return result;\n}\nfunction createPatternAlphabet(pattern) {\n  var mask = {};\n  for (var i = 0, len = pattern.length; i < len; i += 1) {\n    var char = pattern.charAt(i);\n    mask[char] = (mask[char] || 0) | 1 << len - i - 1;\n  }\n  return mask;\n}\nvar BitapSearch = /*#__PURE__*/function () {\n  function BitapSearch(pattern) {\n    var _this5 = this;\n    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref6$location = _ref6.location,\n      location = _ref6$location === void 0 ? Config.location : _ref6$location,\n      _ref6$threshold = _ref6.threshold,\n      threshold = _ref6$threshold === void 0 ? Config.threshold : _ref6$threshold,\n      _ref6$distance = _ref6.distance,\n      distance = _ref6$distance === void 0 ? Config.distance : _ref6$distance,\n      _ref6$includeMatches = _ref6.includeMatches,\n      includeMatches = _ref6$includeMatches === void 0 ? Config.includeMatches : _ref6$includeMatches,\n      _ref6$findAllMatches = _ref6.findAllMatches,\n      findAllMatches = _ref6$findAllMatches === void 0 ? Config.findAllMatches : _ref6$findAllMatches,\n      _ref6$minMatchCharLen = _ref6.minMatchCharLength,\n      minMatchCharLength = _ref6$minMatchCharLen === void 0 ? Config.minMatchCharLength : _ref6$minMatchCharLen,\n      _ref6$isCaseSensitive = _ref6.isCaseSensitive,\n      isCaseSensitive = _ref6$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref6$isCaseSensitive,\n      _ref6$ignoreLocation = _ref6.ignoreLocation,\n      ignoreLocation = _ref6$ignoreLocation === void 0 ? Config.ignoreLocation : _ref6$ignoreLocation;\n    _classCallCheck(this, BitapSearch);\n    this.options = {\n      location: location,\n      threshold: threshold,\n      distance: distance,\n      includeMatches: includeMatches,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      isCaseSensitive: isCaseSensitive,\n      ignoreLocation: ignoreLocation\n    };\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.chunks = [];\n    if (!this.pattern.length) {\n      return;\n    }\n    var addChunk = function addChunk(pattern, startIndex) {\n      _this5.chunks.push({\n        pattern: pattern,\n        alphabet: createPatternAlphabet(pattern),\n        startIndex: startIndex\n      });\n    };\n    var len = this.pattern.length;\n    if (len > MAX_BITS) {\n      var i = 0;\n      var remainder = len % MAX_BITS;\n      var end = len - remainder;\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n      if (remainder) {\n        var startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n  _createClass(BitapSearch, [{\n    key: \"searchIn\",\n    value: function searchIn(text) {\n      var _this$options = this.options,\n        isCaseSensitive = _this$options.isCaseSensitive,\n        includeMatches = _this$options.includeMatches;\n      if (!isCaseSensitive) {\n        text = text.toLowerCase();\n      }\n\n      // Exact match\n      if (this.pattern === text) {\n        var _result = {\n          isMatch: true,\n          score: 0\n        };\n        if (includeMatches) {\n          _result.indices = [[0, text.length - 1]];\n        }\n        return _result;\n      }\n\n      // Otherwise, use Bitap algorithm\n      var _this$options2 = this.options,\n        location = _this$options2.location,\n        distance = _this$options2.distance,\n        threshold = _this$options2.threshold,\n        findAllMatches = _this$options2.findAllMatches,\n        minMatchCharLength = _this$options2.minMatchCharLength,\n        ignoreLocation = _this$options2.ignoreLocation;\n      var allIndices = [];\n      var totalScore = 0;\n      var hasMatches = false;\n      this.chunks.forEach(function (_ref7) {\n        var pattern = _ref7.pattern,\n          alphabet = _ref7.alphabet,\n          startIndex = _ref7.startIndex;\n        var _search = search(text, pattern, alphabet, {\n            location: location + startIndex,\n            distance: distance,\n            threshold: threshold,\n            findAllMatches: findAllMatches,\n            minMatchCharLength: minMatchCharLength,\n            includeMatches: includeMatches,\n            ignoreLocation: ignoreLocation\n          }),\n          isMatch = _search.isMatch,\n          score = _search.score,\n          indices = _search.indices;\n        if (isMatch) {\n          hasMatches = true;\n        }\n        totalScore += score;\n        if (isMatch && indices) {\n          allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));\n        }\n      });\n      var result = {\n        isMatch: hasMatches,\n        score: hasMatches ? totalScore / this.chunks.length : 1\n      };\n      if (hasMatches && includeMatches) {\n        result.indices = allIndices;\n      }\n      return result;\n    }\n  }]);\n  return BitapSearch;\n}();\nvar BaseMatch = /*#__PURE__*/function () {\n  function BaseMatch(pattern) {\n    _classCallCheck(this, BaseMatch);\n    this.pattern = pattern;\n  }\n  _createClass(BaseMatch, [{\n    key: \"search\",\n    value: function search( /*text*/) {}\n  }], [{\n    key: \"isMultiMatch\",\n    value: function isMultiMatch(pattern) {\n      return getMatch(pattern, this.multiRegex);\n    }\n  }, {\n    key: \"isSingleMatch\",\n    value: function isSingleMatch(pattern) {\n      return getMatch(pattern, this.singleRegex);\n    }\n  }]);\n  return BaseMatch;\n}();\nfunction getMatch(pattern, exp) {\n  var matches = pattern.match(exp);\n  return matches ? matches[1] : null;\n}\n\n// Token: 'file\nvar ExactMatch = /*#__PURE__*/function (_BaseMatch) {\n  _inherits(ExactMatch, _BaseMatch);\n  var _super = _createSuper(ExactMatch);\n  function ExactMatch(pattern) {\n    _classCallCheck(this, ExactMatch);\n    return _super.call(this, pattern);\n  }\n  _createClass(ExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = text === this.pattern;\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, this.pattern.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^=\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^=(.*)$/;\n    }\n  }]);\n  return ExactMatch;\n}(BaseMatch); // Token: !fire\nvar InverseExactMatch = /*#__PURE__*/function (_BaseMatch2) {\n  _inherits(InverseExactMatch, _BaseMatch2);\n  var _super2 = _createSuper(InverseExactMatch);\n  function InverseExactMatch(pattern) {\n    _classCallCheck(this, InverseExactMatch);\n    return _super2.call(this, pattern);\n  }\n  _createClass(InverseExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var index = text.indexOf(this.pattern);\n      var isMatch = index === -1;\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, text.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'inverse-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^!\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^!(.*)$/;\n    }\n  }]);\n  return InverseExactMatch;\n}(BaseMatch); // Token: ^file\nvar PrefixExactMatch = /*#__PURE__*/function (_BaseMatch3) {\n  _inherits(PrefixExactMatch, _BaseMatch3);\n  var _super3 = _createSuper(PrefixExactMatch);\n  function PrefixExactMatch(pattern) {\n    _classCallCheck(this, PrefixExactMatch);\n    return _super3.call(this, pattern);\n  }\n  _createClass(PrefixExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = text.startsWith(this.pattern);\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, this.pattern.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'prefix-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^\\^\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^\\^(.*)$/;\n    }\n  }]);\n  return PrefixExactMatch;\n}(BaseMatch); // Token: !^fire\nvar InversePrefixExactMatch = /*#__PURE__*/function (_BaseMatch4) {\n  _inherits(InversePrefixExactMatch, _BaseMatch4);\n  var _super4 = _createSuper(InversePrefixExactMatch);\n  function InversePrefixExactMatch(pattern) {\n    _classCallCheck(this, InversePrefixExactMatch);\n    return _super4.call(this, pattern);\n  }\n  _createClass(InversePrefixExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = !text.startsWith(this.pattern);\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, text.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'inverse-prefix-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^!\\^\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^!\\^(.*)$/;\n    }\n  }]);\n  return InversePrefixExactMatch;\n}(BaseMatch); // Token: .file$\nvar SuffixExactMatch = /*#__PURE__*/function (_BaseMatch5) {\n  _inherits(SuffixExactMatch, _BaseMatch5);\n  var _super5 = _createSuper(SuffixExactMatch);\n  function SuffixExactMatch(pattern) {\n    _classCallCheck(this, SuffixExactMatch);\n    return _super5.call(this, pattern);\n  }\n  _createClass(SuffixExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = text.endsWith(this.pattern);\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [text.length - this.pattern.length, text.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'suffix-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^\"(.*)\"\\$$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^(.*)\\$$/;\n    }\n  }]);\n  return SuffixExactMatch;\n}(BaseMatch); // Token: !.file$\nvar InverseSuffixExactMatch = /*#__PURE__*/function (_BaseMatch6) {\n  _inherits(InverseSuffixExactMatch, _BaseMatch6);\n  var _super6 = _createSuper(InverseSuffixExactMatch);\n  function InverseSuffixExactMatch(pattern) {\n    _classCallCheck(this, InverseSuffixExactMatch);\n    return _super6.call(this, pattern);\n  }\n  _createClass(InverseSuffixExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = !text.endsWith(this.pattern);\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, text.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'inverse-suffix-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^!\"(.*)\"\\$$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^!(.*)\\$$/;\n    }\n  }]);\n  return InverseSuffixExactMatch;\n}(BaseMatch);\nvar FuzzyMatch = /*#__PURE__*/function (_BaseMatch7) {\n  _inherits(FuzzyMatch, _BaseMatch7);\n  var _super7 = _createSuper(FuzzyMatch);\n  function FuzzyMatch(pattern) {\n    var _this6;\n    var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref8$location = _ref8.location,\n      location = _ref8$location === void 0 ? Config.location : _ref8$location,\n      _ref8$threshold = _ref8.threshold,\n      threshold = _ref8$threshold === void 0 ? Config.threshold : _ref8$threshold,\n      _ref8$distance = _ref8.distance,\n      distance = _ref8$distance === void 0 ? Config.distance : _ref8$distance,\n      _ref8$includeMatches = _ref8.includeMatches,\n      includeMatches = _ref8$includeMatches === void 0 ? Config.includeMatches : _ref8$includeMatches,\n      _ref8$findAllMatches = _ref8.findAllMatches,\n      findAllMatches = _ref8$findAllMatches === void 0 ? Config.findAllMatches : _ref8$findAllMatches,\n      _ref8$minMatchCharLen = _ref8.minMatchCharLength,\n      minMatchCharLength = _ref8$minMatchCharLen === void 0 ? Config.minMatchCharLength : _ref8$minMatchCharLen,\n      _ref8$isCaseSensitive = _ref8.isCaseSensitive,\n      isCaseSensitive = _ref8$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref8$isCaseSensitive,\n      _ref8$ignoreLocation = _ref8.ignoreLocation,\n      ignoreLocation = _ref8$ignoreLocation === void 0 ? Config.ignoreLocation : _ref8$ignoreLocation;\n    _classCallCheck(this, FuzzyMatch);\n    _this6 = _super7.call(this, pattern);\n    _this6._bitapSearch = new BitapSearch(pattern, {\n      location: location,\n      threshold: threshold,\n      distance: distance,\n      includeMatches: includeMatches,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      isCaseSensitive: isCaseSensitive,\n      ignoreLocation: ignoreLocation\n    });\n    return _this6;\n  }\n  _createClass(FuzzyMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      return this._bitapSearch.searchIn(text);\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'fuzzy';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^(.*)$/;\n    }\n  }]);\n  return FuzzyMatch;\n}(BaseMatch); // Token: 'file\nvar IncludeMatch = /*#__PURE__*/function (_BaseMatch8) {\n  _inherits(IncludeMatch, _BaseMatch8);\n  var _super8 = _createSuper(IncludeMatch);\n  function IncludeMatch(pattern) {\n    _classCallCheck(this, IncludeMatch);\n    return _super8.call(this, pattern);\n  }\n  _createClass(IncludeMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var location = 0;\n      var index;\n      var indices = [];\n      var patternLen = this.pattern.length;\n\n      // Get all exact matches\n      while ((index = text.indexOf(this.pattern, location)) > -1) {\n        location = index + patternLen;\n        indices.push([index, location - 1]);\n      }\n      var isMatch = !!indices.length;\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: indices\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'include';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^'\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^'(.*)$/;\n    }\n  }]);\n  return IncludeMatch;\n}(BaseMatch); // ❗Order is important. DO NOT CHANGE.\nvar searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];\nvar searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nvar SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nvar OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return pattern.split(OR_TOKEN).map(function (item) {\n    var query = item.trim().split(SPACE_RE).filter(function (item) {\n      return item && !!item.trim();\n    });\n    var results = [];\n    for (var i = 0, len = query.length; i < len; i += 1) {\n      var queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      var found = false;\n      var idx = -1;\n      while (!found && ++idx < searchersLen) {\n        var searcher = searchers[idx];\n        var token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n      if (found) {\n        continue;\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        var _searcher = searchers[idx];\n        var _token = _searcher.isSingleMatch(queryItem);\n        if (_token) {\n          results.push(new _searcher(_token, options));\n          break;\n        }\n      }\n    }\n    return results;\n  });\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nvar MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\n/**\r\n * Command-like searching\r\n * ======================\r\n *\r\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\r\n * search in a given text.\r\n *\r\n * Search syntax:\r\n *\r\n * | Token       | Match type                 | Description                            |\r\n * | ----------- | -------------------------- | -------------------------------------- |\r\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\r\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\r\n * | `'python`   | include-match              | Items that include `python`            |\r\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\r\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\r\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\r\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\r\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\r\n *\r\n * A single pipe character acts as an OR operator. For example, the following\r\n * query matches entries that start with `core` and end with either`go`, `rb`,\r\n * or`py`.\r\n *\r\n * ```\r\n * ^core go$ | rb$ | py$\r\n * ```\r\n */\nvar ExtendedSearch = /*#__PURE__*/function () {\n  function ExtendedSearch(pattern) {\n    var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref9$isCaseSensitive = _ref9.isCaseSensitive,\n      isCaseSensitive = _ref9$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref9$isCaseSensitive,\n      _ref9$includeMatches = _ref9.includeMatches,\n      includeMatches = _ref9$includeMatches === void 0 ? Config.includeMatches : _ref9$includeMatches,\n      _ref9$minMatchCharLen = _ref9.minMatchCharLength,\n      minMatchCharLength = _ref9$minMatchCharLen === void 0 ? Config.minMatchCharLength : _ref9$minMatchCharLen,\n      _ref9$ignoreLocation = _ref9.ignoreLocation,\n      ignoreLocation = _ref9$ignoreLocation === void 0 ? Config.ignoreLocation : _ref9$ignoreLocation,\n      _ref9$findAllMatches = _ref9.findAllMatches,\n      findAllMatches = _ref9$findAllMatches === void 0 ? Config.findAllMatches : _ref9$findAllMatches,\n      _ref9$location = _ref9.location,\n      location = _ref9$location === void 0 ? Config.location : _ref9$location,\n      _ref9$threshold = _ref9.threshold,\n      threshold = _ref9$threshold === void 0 ? Config.threshold : _ref9$threshold,\n      _ref9$distance = _ref9.distance,\n      distance = _ref9$distance === void 0 ? Config.distance : _ref9$distance;\n    _classCallCheck(this, ExtendedSearch);\n    this.query = null;\n    this.options = {\n      isCaseSensitive: isCaseSensitive,\n      includeMatches: includeMatches,\n      minMatchCharLength: minMatchCharLength,\n      findAllMatches: findAllMatches,\n      ignoreLocation: ignoreLocation,\n      location: location,\n      threshold: threshold,\n      distance: distance\n    };\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n  _createClass(ExtendedSearch, [{\n    key: \"searchIn\",\n    value: function searchIn(text) {\n      var query = this.query;\n      if (!query) {\n        return {\n          isMatch: false,\n          score: 1\n        };\n      }\n      var _this$options3 = this.options,\n        includeMatches = _this$options3.includeMatches,\n        isCaseSensitive = _this$options3.isCaseSensitive;\n      text = isCaseSensitive ? text : text.toLowerCase();\n      var numMatches = 0;\n      var allIndices = [];\n      var totalScore = 0;\n\n      // ORs\n      for (var i = 0, qLen = query.length; i < qLen; i += 1) {\n        var _searchers = query[i];\n\n        // Reset indices\n        allIndices.length = 0;\n        numMatches = 0;\n\n        // ANDs\n        for (var j = 0, pLen = _searchers.length; j < pLen; j += 1) {\n          var searcher = _searchers[j];\n          var _searcher$search = searcher.search(text),\n            isMatch = _searcher$search.isMatch,\n            indices = _searcher$search.indices,\n            score = _searcher$search.score;\n          if (isMatch) {\n            numMatches += 1;\n            totalScore += score;\n            if (includeMatches) {\n              var type = searcher.constructor.type;\n              if (MultiMatchSet.has(type)) {\n                allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));\n              } else {\n                allIndices.push(indices);\n              }\n            }\n          } else {\n            totalScore = 0;\n            numMatches = 0;\n            allIndices.length = 0;\n            break;\n          }\n        }\n\n        // OR condition, so if TRUE, return\n        if (numMatches) {\n          var result = {\n            isMatch: true,\n            score: totalScore / numMatches\n          };\n          if (includeMatches) {\n            result.indices = allIndices;\n          }\n          return result;\n        }\n      }\n\n      // Nothing was matched\n      return {\n        isMatch: false,\n        score: 1\n      };\n    }\n  }], [{\n    key: \"condition\",\n    value: function condition(_, options) {\n      return options.useExtendedSearch;\n    }\n  }]);\n  return ExtendedSearch;\n}();\nvar registeredSearchers = [];\nfunction register() {\n  registeredSearchers.push.apply(registeredSearchers, arguments);\n}\nfunction createSearcher(pattern, options) {\n  for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    var searcherClass = registeredSearchers[i];\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options);\n    }\n  }\n  return new BitapSearch(pattern, options);\n}\nvar LogicalOperator = {\n  AND: '$and',\n  OR: '$or'\n};\nvar KeyType = {\n  PATH: '$path',\n  PATTERN: '$val'\n};\nvar isExpression = function isExpression(query) {\n  return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n};\nvar isPath = function isPath(query) {\n  return !!query[KeyType.PATH];\n};\nvar isLeaf = function isLeaf(query) {\n  return !isArray(query) && isObject(query) && !isExpression(query);\n};\nvar convertToExplicit = function convertToExplicit(query) {\n  return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function (key) {\n    return _defineProperty({}, key, query[key]);\n  }));\n};\n\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options) {\n  var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref12$auto = _ref12.auto,\n    auto = _ref12$auto === void 0 ? true : _ref12$auto;\n  var next = function next(query) {\n    var keys = Object.keys(query);\n    var isQueryPath = isPath(query);\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n      return next(convertToExplicit(query));\n    }\n    if (isLeaf(query)) {\n      var key = isQueryPath ? query[KeyType.PATH] : keys[0];\n      var pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\n      }\n      var obj = {\n        keyId: createKeyId(key),\n        pattern: pattern\n      };\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n      return obj;\n    }\n    var node = {\n      children: [],\n      operator: keys[0]\n    };\n    keys.forEach(function (key) {\n      var value = query[key];\n      if (isArray(value)) {\n        value.forEach(function (item) {\n          node.children.push(next(item));\n        });\n      }\n    });\n    return node;\n  };\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n  return next(query);\n}\n\n// Practical scoring function\nfunction computeScore(results, _ref13) {\n  var _ref13$ignoreFieldNor = _ref13.ignoreFieldNorm,\n    ignoreFieldNorm = _ref13$ignoreFieldNor === void 0 ? Config.ignoreFieldNorm : _ref13$ignoreFieldNor;\n  results.forEach(function (result) {\n    var totalScore = 1;\n    result.matches.forEach(function (_ref14) {\n      var key = _ref14.key,\n        norm = _ref14.norm,\n        score = _ref14.score;\n      var weight = key ? key.weight : null;\n      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));\n    });\n    result.score = totalScore;\n  });\n}\nfunction transformMatches(result, data) {\n  var matches = result.matches;\n  data.matches = [];\n  if (!isDefined(matches)) {\n    return;\n  }\n  matches.forEach(function (match) {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return;\n    }\n    var indices = match.indices,\n      value = match.value;\n    var obj = {\n      indices: indices,\n      value: value\n    };\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n    data.matches.push(obj);\n  });\n}\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\nfunction format(results, docs) {\n  var _ref15 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref15$includeMatches = _ref15.includeMatches,\n    includeMatches = _ref15$includeMatches === void 0 ? Config.includeMatches : _ref15$includeMatches,\n    _ref15$includeScore = _ref15.includeScore,\n    includeScore = _ref15$includeScore === void 0 ? Config.includeScore : _ref15$includeScore;\n  var transformers = [];\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n  return results.map(function (result) {\n    var idx = result.idx;\n    var data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n    if (transformers.length) {\n      transformers.forEach(function (transformer) {\n        transformer(result, data);\n      });\n    }\n    return data;\n  });\n}\nvar Fuse = /*#__PURE__*/function () {\n  function Fuse(docs) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var index = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, Fuse);\n    this.options = _objectSpread(_objectSpread({}, Config), options);\n    if (this.options.useExtendedSearch && !true) {\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);\n    }\n    this._keyStore = new KeyStore(this.options.keys);\n    this.setCollection(docs, index);\n  }\n  _createClass(Fuse, [{\n    key: \"setCollection\",\n    value: function setCollection(docs, index) {\n      this._docs = docs;\n      if (index && !(index instanceof FuseIndex)) {\n        throw new Error(INCORRECT_INDEX_TYPE);\n      }\n      this._myIndex = index || createIndex(this.options.keys, this._docs, {\n        getFn: this.options.getFn,\n        fieldNormWeight: this.options.fieldNormWeight\n      });\n    }\n  }, {\n    key: \"add\",\n    value: function add(doc) {\n      if (!isDefined(doc)) {\n        return;\n      }\n      this._docs.push(doc);\n      this._myIndex.add(doc);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function /* doc, idx */ () {\n        return false;\n      };\n      var results = [];\n      for (var i = 0, len = this._docs.length; i < len; i += 1) {\n        var doc = this._docs[i];\n        if (predicate(doc, i)) {\n          this.removeAt(i);\n          i -= 1;\n          len -= 1;\n          results.push(doc);\n        }\n      }\n      return results;\n    }\n  }, {\n    key: \"removeAt\",\n    value: function removeAt(idx) {\n      this._docs.splice(idx, 1);\n      this._myIndex.removeAt(idx);\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex() {\n      return this._myIndex;\n    }\n  }, {\n    key: \"search\",\n    value: function search(query) {\n      var _ref16 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref16$limit = _ref16.limit,\n        limit = _ref16$limit === void 0 ? -1 : _ref16$limit;\n      var _this$options4 = this.options,\n        includeMatches = _this$options4.includeMatches,\n        includeScore = _this$options4.includeScore,\n        shouldSort = _this$options4.shouldSort,\n        sortFn = _this$options4.sortFn,\n        ignoreFieldNorm = _this$options4.ignoreFieldNorm;\n      var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\n      computeScore(results, {\n        ignoreFieldNorm: ignoreFieldNorm\n      });\n      if (shouldSort) {\n        results.sort(sortFn);\n      }\n      if (isNumber(limit) && limit > -1) {\n        results = results.slice(0, limit);\n      }\n      return format(results, this._docs, {\n        includeMatches: includeMatches,\n        includeScore: includeScore\n      });\n    }\n  }, {\n    key: \"_searchStringList\",\n    value: function _searchStringList(query) {\n      var searcher = createSearcher(query, this.options);\n      var records = this._myIndex.records;\n      var results = [];\n\n      // Iterate over every string in the index\n      records.forEach(function (_ref17) {\n        var text = _ref17.v,\n          idx = _ref17.i,\n          norm = _ref17.n;\n        if (!isDefined(text)) {\n          return;\n        }\n        var _searcher$searchIn = searcher.searchIn(text),\n          isMatch = _searcher$searchIn.isMatch,\n          score = _searcher$searchIn.score,\n          indices = _searcher$searchIn.indices;\n        if (isMatch) {\n          results.push({\n            item: text,\n            idx: idx,\n            matches: [{\n              score: score,\n              value: text,\n              norm: norm,\n              indices: indices\n            }]\n          });\n        }\n      });\n      return results;\n    }\n  }, {\n    key: \"_searchLogical\",\n    value: function _searchLogical(query) {\n      var _this7 = this;\n      var expression = parse(query, this.options);\n      var evaluate = function evaluate(node, item, idx) {\n        if (!node.children) {\n          var keyId = node.keyId,\n            searcher = node.searcher;\n          var matches = _this7._findMatches({\n            key: _this7._keyStore.get(keyId),\n            value: _this7._myIndex.getValueForItemAtKeyId(item, keyId),\n            searcher: searcher\n          });\n          if (matches && matches.length) {\n            return [{\n              idx: idx,\n              item: item,\n              matches: matches\n            }];\n          }\n          return [];\n        }\n        var res = [];\n        for (var i = 0, len = node.children.length; i < len; i += 1) {\n          var child = node.children[i];\n          var result = evaluate(child, item, idx);\n          if (result.length) {\n            res.push.apply(res, _toConsumableArray(result));\n          } else if (node.operator === LogicalOperator.AND) {\n            return [];\n          }\n        }\n        return res;\n      };\n      var records = this._myIndex.records;\n      var resultMap = {};\n      var results = [];\n      records.forEach(function (_ref18) {\n        var item = _ref18.$,\n          idx = _ref18.i;\n        if (isDefined(item)) {\n          var expResults = evaluate(expression, item, idx);\n          if (expResults.length) {\n            // Dedupe when adding\n            if (!resultMap[idx]) {\n              resultMap[idx] = {\n                idx: idx,\n                item: item,\n                matches: []\n              };\n              results.push(resultMap[idx]);\n            }\n            expResults.forEach(function (_ref19) {\n              var _resultMap$idx$matche;\n              var matches = _ref19.matches;\n              (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));\n            });\n          }\n        }\n      });\n      return results;\n    }\n  }, {\n    key: \"_searchObjectList\",\n    value: function _searchObjectList(query) {\n      var _this8 = this;\n      var searcher = createSearcher(query, this.options);\n      var _this$_myIndex = this._myIndex,\n        keys = _this$_myIndex.keys,\n        records = _this$_myIndex.records;\n      var results = [];\n\n      // List is Array<Object>\n      records.forEach(function (_ref20) {\n        var item = _ref20.$,\n          idx = _ref20.i;\n        if (!isDefined(item)) {\n          return;\n        }\n        var matches = [];\n\n        // Iterate over every key (i.e, path), and fetch the value at that key\n        keys.forEach(function (key, keyIndex) {\n          matches.push.apply(matches, _toConsumableArray(_this8._findMatches({\n            key: key,\n            value: item[keyIndex],\n            searcher: searcher\n          })));\n        });\n        if (matches.length) {\n          results.push({\n            idx: idx,\n            item: item,\n            matches: matches\n          });\n        }\n      });\n      return results;\n    }\n  }, {\n    key: \"_findMatches\",\n    value: function _findMatches(_ref21) {\n      var key = _ref21.key,\n        value = _ref21.value,\n        searcher = _ref21.searcher;\n      if (!isDefined(value)) {\n        return [];\n      }\n      var matches = [];\n      if (isArray(value)) {\n        value.forEach(function (_ref22) {\n          var text = _ref22.v,\n            idx = _ref22.i,\n            norm = _ref22.n;\n          if (!isDefined(text)) {\n            return;\n          }\n          var _searcher$searchIn2 = searcher.searchIn(text),\n            isMatch = _searcher$searchIn2.isMatch,\n            score = _searcher$searchIn2.score,\n            indices = _searcher$searchIn2.indices;\n          if (isMatch) {\n            matches.push({\n              score: score,\n              key: key,\n              value: text,\n              idx: idx,\n              norm: norm,\n              indices: indices\n            });\n          }\n        });\n      } else {\n        var text = value.v,\n          _norm = value.n;\n        var _searcher$searchIn3 = searcher.searchIn(text),\n          isMatch = _searcher$searchIn3.isMatch,\n          score = _searcher$searchIn3.score,\n          indices = _searcher$searchIn3.indices;\n        if (isMatch) {\n          matches.push({\n            score: score,\n            key: key,\n            value: text,\n            norm: _norm,\n            indices: indices\n          });\n        }\n      }\n      return matches;\n    }\n  }]);\n  return Fuse;\n}();\nFuse.version = '6.6.2';\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n{\n  Fuse.parseQuery = parse;\n}\n{\n  register(ExtendedSearch);\n}\nexport { Fuse as default };","map":{"version":3,"names":["isArray","value","Array","getTag","INFINITY","baseToString","result","toString","isString","isNumber","isBoolean","isObjectLike","isObject","isDefined","undefined","isBlank","trim","length","Object","prototype","call","EXTENDED_SEARCH_UNAVAILABLE","INCORRECT_INDEX_TYPE","LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY","key","concat","PATTERN_LENGTH_TOO_LARGE","max","MISSING_KEY_PROPERTY","name","INVALID_KEY_WEIGHT_VALUE","hasOwn","hasOwnProperty","KeyStore","keys","_this","_classCallCheck","_keys","_keyMap","totalWeight","forEach","obj","createKey","weight","push","id","_createClass","get","keyId","toJSON","JSON","stringify","path","src","getFn","createKeyPath","createKeyId","Error","split","join","list","arr","deepGet","index","i","len","MatchOptions","includeMatches","findAllMatches","minMatchCharLength","BasicOptions","isCaseSensitive","includeScore","shouldSort","sortFn","a","b","score","idx","FuzzyOptions","location","threshold","distance","AdvancedOptions","useExtendedSearch","ignoreLocation","ignoreFieldNorm","fieldNormWeight","Config","_objectSpread","SPACE","norm","arguments","mantissa","cache","Map","m","Math","pow","numTokens","match","has","n","parseFloat","round","set","clear","FuseIndex","_ref","_ref$getFn","_ref$fieldNormWeight","isCreated","setIndexRecords","setSources","docs","records","setKeys","_this2","_keysMap","create","_this3","doc","docIndex","_addString","_addObject","add","size","removeAt","splice","getValueForItemAtKeyId","item","record","v","_this4","$","keyIndex","subRecords","stack","nestedArrIndex","_stack$pop","pop","subRecord","k","createIndex","_ref2","_ref2$getFn","_ref2$fieldNormWeight","myIndex","map","parseIndex","data","_ref3","_ref3$getFn","_ref3$fieldNormWeight","computeScore$1","pattern","_ref4","_ref4$errors","errors","_ref4$currentLocation","currentLocation","_ref4$expectedLocatio","expectedLocation","_ref4$distance","_ref4$ignoreLocation","accuracy","proximity","abs","convertMaskToIndices","matchmask","indices","start","end","MAX_BITS","search","text","patternAlphabet","_ref5","_ref5$location","_ref5$distance","_ref5$threshold","_ref5$findAllMatches","_ref5$minMatchCharLen","_ref5$includeMatches","_ref5$ignoreLocation","patternLen","textLen","min","currentThreshold","bestLocation","computeMatches","matchMask","indexOf","lastBitArr","finalScore","binMax","mask","binMin","binMid","floor","finish","bitArr","j","charMatch","charAt","isMatch","createPatternAlphabet","char","BitapSearch","_this5","_ref6","_ref6$location","_ref6$threshold","_ref6$distance","_ref6$includeMatches","_ref6$findAllMatches","_ref6$minMatchCharLen","_ref6$isCaseSensitive","_ref6$ignoreLocation","options","toLowerCase","chunks","addChunk","startIndex","alphabet","remainder","substr","searchIn","_this$options","_this$options2","allIndices","totalScore","hasMatches","_ref7","_search","_toConsumableArray","BaseMatch","isMultiMatch","getMatch","multiRegex","isSingleMatch","singleRegex","exp","matches","ExactMatch","_BaseMatch","_inherits","_super","_createSuper","InverseExactMatch","_BaseMatch2","_super2","PrefixExactMatch","_BaseMatch3","_super3","startsWith","InversePrefixExactMatch","_BaseMatch4","_super4","SuffixExactMatch","_BaseMatch5","_super5","endsWith","InverseSuffixExactMatch","_BaseMatch6","_super6","FuzzyMatch","_BaseMatch7","_super7","_this6","_ref8","_ref8$location","_ref8$threshold","_ref8$distance","_ref8$includeMatches","_ref8$findAllMatches","_ref8$minMatchCharLen","_ref8$isCaseSensitive","_ref8$ignoreLocation","_bitapSearch","IncludeMatch","_BaseMatch8","_super8","searchers","searchersLen","SPACE_RE","OR_TOKEN","parseQuery","query","filter","results","queryItem","found","searcher","token","MultiMatchSet","Set","type","ExtendedSearch","_ref9","_ref9$isCaseSensitive","_ref9$includeMatches","_ref9$minMatchCharLen","_ref9$ignoreLocation","_ref9$findAllMatches","_ref9$location","_ref9$threshold","_ref9$distance","_this$options3","numMatches","qLen","pLen","_searcher$search","constructor","condition","_","registeredSearchers","register","apply","createSearcher","searcherClass","LogicalOperator","AND","OR","KeyType","PATH","PATTERN","isExpression","isPath","isLeaf","convertToExplicit","_defineProperty","parse","_ref12","_ref12$auto","auto","next","isQueryPath","node","children","operator","computeScore","_ref13","_ref13$ignoreFieldNor","_ref14","Number","EPSILON","transformMatches","refIndex","transformScore","format","_ref15","_ref15$includeMatches","_ref15$includeScore","transformers","transformer","Fuse","_keyStore","setCollection","_docs","_myIndex","remove","predicate","getIndex","_ref16","_ref16$limit","limit","_this$options4","_searchStringList","_searchObjectList","_searchLogical","sort","slice","_ref17","_searcher$searchIn","_this7","expression","evaluate","_findMatches","res","child","resultMap","_ref18","expResults","_ref19","_resultMap$idx$matche","_this8","_this$_myIndex","_ref20","_ref21","_ref22","_searcher$searchIn2","_searcher$searchIn3","version","config","default"],"sources":["C:/Users/LENOVO/OneDrive/E-com site/app/node_modules/fuse.js/dist/fuse.esm.js"],"sourcesContent":["/**\r\n * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)\r\n *\r\n * Copyright (c) 2022 Kiro Risk (http://kiro.me)\r\n * All Rights Reserved. Apache Software License 2.0\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n */\r\n\r\nfunction isArray(value) {\r\n  return !Array.isArray\r\n    ? getTag(value) === '[object Array]'\r\n    : Array.isArray(value)\r\n}\r\n\r\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\r\nconst INFINITY = 1 / 0;\r\nfunction baseToString(value) {\r\n  // Exit early for strings to avoid a performance hit in some environments.\r\n  if (typeof value == 'string') {\r\n    return value\r\n  }\r\n  let result = value + '';\r\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\r\n}\r\n\r\nfunction toString(value) {\r\n  return value == null ? '' : baseToString(value)\r\n}\r\n\r\nfunction isString(value) {\r\n  return typeof value === 'string'\r\n}\r\n\r\nfunction isNumber(value) {\r\n  return typeof value === 'number'\r\n}\r\n\r\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\r\nfunction isBoolean(value) {\r\n  return (\r\n    value === true ||\r\n    value === false ||\r\n    (isObjectLike(value) && getTag(value) == '[object Boolean]')\r\n  )\r\n}\r\n\r\nfunction isObject(value) {\r\n  return typeof value === 'object'\r\n}\r\n\r\n// Checks if `value` is object-like.\r\nfunction isObjectLike(value) {\r\n  return isObject(value) && value !== null\r\n}\r\n\r\nfunction isDefined(value) {\r\n  return value !== undefined && value !== null\r\n}\r\n\r\nfunction isBlank(value) {\r\n  return !value.trim().length\r\n}\r\n\r\n// Gets the `toStringTag` of `value`.\r\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\r\nfunction getTag(value) {\r\n  return value == null\r\n    ? value === undefined\r\n      ? '[object Undefined]'\r\n      : '[object Null]'\r\n    : Object.prototype.toString.call(value)\r\n}\r\n\r\nconst EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\r\n\r\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\r\n\r\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>\r\n  `Invalid value for key ${key}`;\r\n\r\nconst PATTERN_LENGTH_TOO_LARGE = (max) =>\r\n  `Pattern length exceeds max of ${max}.`;\r\n\r\nconst MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;\r\n\r\nconst INVALID_KEY_WEIGHT_VALUE = (key) =>\r\n  `Property 'weight' in key '${key}' must be a positive integer`;\r\n\r\nconst hasOwn = Object.prototype.hasOwnProperty;\r\n\r\nclass KeyStore {\r\n  constructor(keys) {\r\n    this._keys = [];\r\n    this._keyMap = {};\r\n\r\n    let totalWeight = 0;\r\n\r\n    keys.forEach((key) => {\r\n      let obj = createKey(key);\r\n\r\n      totalWeight += obj.weight;\r\n\r\n      this._keys.push(obj);\r\n      this._keyMap[obj.id] = obj;\r\n\r\n      totalWeight += obj.weight;\r\n    });\r\n\r\n    // Normalize weights so that their sum is equal to 1\r\n    this._keys.forEach((key) => {\r\n      key.weight /= totalWeight;\r\n    });\r\n  }\r\n  get(keyId) {\r\n    return this._keyMap[keyId]\r\n  }\r\n  keys() {\r\n    return this._keys\r\n  }\r\n  toJSON() {\r\n    return JSON.stringify(this._keys)\r\n  }\r\n}\r\n\r\nfunction createKey(key) {\r\n  let path = null;\r\n  let id = null;\r\n  let src = null;\r\n  let weight = 1;\r\n  let getFn = null;\r\n\r\n  if (isString(key) || isArray(key)) {\r\n    src = key;\r\n    path = createKeyPath(key);\r\n    id = createKeyId(key);\r\n  } else {\r\n    if (!hasOwn.call(key, 'name')) {\r\n      throw new Error(MISSING_KEY_PROPERTY('name'))\r\n    }\r\n\r\n    const name = key.name;\r\n    src = name;\r\n\r\n    if (hasOwn.call(key, 'weight')) {\r\n      weight = key.weight;\r\n\r\n      if (weight <= 0) {\r\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))\r\n      }\r\n    }\r\n\r\n    path = createKeyPath(name);\r\n    id = createKeyId(name);\r\n    getFn = key.getFn;\r\n  }\r\n\r\n  return { path, id, weight, src, getFn }\r\n}\r\n\r\nfunction createKeyPath(key) {\r\n  return isArray(key) ? key : key.split('.')\r\n}\r\n\r\nfunction createKeyId(key) {\r\n  return isArray(key) ? key.join('.') : key\r\n}\r\n\r\nfunction get(obj, path) {\r\n  let list = [];\r\n  let arr = false;\r\n\r\n  const deepGet = (obj, path, index) => {\r\n    if (!isDefined(obj)) {\r\n      return\r\n    }\r\n    if (!path[index]) {\r\n      // If there's no path left, we've arrived at the object we care about.\r\n      list.push(obj);\r\n    } else {\r\n      let key = path[index];\r\n\r\n      const value = obj[key];\r\n\r\n      if (!isDefined(value)) {\r\n        return\r\n      }\r\n\r\n      // If we're at the last value in the path, and if it's a string/number/bool,\r\n      // add it to the list\r\n      if (\r\n        index === path.length - 1 &&\r\n        (isString(value) || isNumber(value) || isBoolean(value))\r\n      ) {\r\n        list.push(toString(value));\r\n      } else if (isArray(value)) {\r\n        arr = true;\r\n        // Search each item in the array.\r\n        for (let i = 0, len = value.length; i < len; i += 1) {\r\n          deepGet(value[i], path, index + 1);\r\n        }\r\n      } else if (path.length) {\r\n        // An object. Recurse further.\r\n        deepGet(value, path, index + 1);\r\n      }\r\n    }\r\n  };\r\n\r\n  // Backwards compatibility (since path used to be a string)\r\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\r\n\r\n  return arr ? list : list[0]\r\n}\r\n\r\nconst MatchOptions = {\r\n  // Whether the matches should be included in the result set. When `true`, each record in the result\r\n  // set will include the indices of the matched characters.\r\n  // These can consequently be used for highlighting purposes.\r\n  includeMatches: false,\r\n  // When `true`, the matching function will continue to the end of a search pattern even if\r\n  // a perfect match has already been located in the string.\r\n  findAllMatches: false,\r\n  // Minimum number of characters that must be matched before a result is considered a match\r\n  minMatchCharLength: 1\r\n};\r\n\r\nconst BasicOptions = {\r\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\r\n  // match is found before the end of the same input.\r\n  isCaseSensitive: false,\r\n  // When true, the matching function will continue to the end of a search pattern even if\r\n  includeScore: false,\r\n  // List of properties that will be searched. This also supports nested properties.\r\n  keys: [],\r\n  // Whether to sort the result list, by score\r\n  shouldSort: true,\r\n  // Default sort function: sort by ascending score, ascending index\r\n  sortFn: (a, b) =>\r\n    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1\r\n};\r\n\r\nconst FuzzyOptions = {\r\n  // Approximately where in the text is the pattern expected to be found?\r\n  location: 0,\r\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\r\n  // (of both letters and location), a threshold of '1.0' would match anything.\r\n  threshold: 0.6,\r\n  // Determines how close the match must be to the fuzzy location (specified above).\r\n  // An exact letter match which is 'distance' characters away from the fuzzy location\r\n  // would score as a complete mismatch. A distance of '0' requires the match be at\r\n  // the exact location specified, a threshold of '1000' would require a perfect match\r\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\r\n  distance: 100\r\n};\r\n\r\nconst AdvancedOptions = {\r\n  // When `true`, it enables the use of unix-like search commands\r\n  useExtendedSearch: false,\r\n  // The get function to use when fetching an object's properties.\r\n  // The default will search nested paths *ie foo.bar.baz*\r\n  getFn: get,\r\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\r\n  // where in the string the pattern appears.\r\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\r\n  ignoreLocation: false,\r\n  // When `true`, the calculation for the relevance score (used for sorting) will\r\n  // ignore the field-length norm.\r\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\r\n  ignoreFieldNorm: false,\r\n  // The weight to determine how much field length norm effects scoring.\r\n  fieldNormWeight: 1\r\n};\r\n\r\nvar Config = {\r\n  ...BasicOptions,\r\n  ...MatchOptions,\r\n  ...FuzzyOptions,\r\n  ...AdvancedOptions\r\n};\r\n\r\nconst SPACE = /[^ ]+/g;\r\n\r\n// Field-length norm: the shorter the field, the higher the weight.\r\n// Set to 3 decimals to reduce index size.\r\nfunction norm(weight = 1, mantissa = 3) {\r\n  const cache = new Map();\r\n  const m = Math.pow(10, mantissa);\r\n\r\n  return {\r\n    get(value) {\r\n      const numTokens = value.match(SPACE).length;\r\n\r\n      if (cache.has(numTokens)) {\r\n        return cache.get(numTokens)\r\n      }\r\n\r\n      // Default function is 1/sqrt(x), weight makes that variable\r\n      const norm = 1 / Math.pow(numTokens, 0.5 * weight);\r\n\r\n      // In place of `toFixed(mantissa)`, for faster computation\r\n      const n = parseFloat(Math.round(norm * m) / m);\r\n\r\n      cache.set(numTokens, n);\r\n\r\n      return n\r\n    },\r\n    clear() {\r\n      cache.clear();\r\n    }\r\n  }\r\n}\r\n\r\nclass FuseIndex {\r\n  constructor({\r\n    getFn = Config.getFn,\r\n    fieldNormWeight = Config.fieldNormWeight\r\n  } = {}) {\r\n    this.norm = norm(fieldNormWeight, 3);\r\n    this.getFn = getFn;\r\n    this.isCreated = false;\r\n\r\n    this.setIndexRecords();\r\n  }\r\n  setSources(docs = []) {\r\n    this.docs = docs;\r\n  }\r\n  setIndexRecords(records = []) {\r\n    this.records = records;\r\n  }\r\n  setKeys(keys = []) {\r\n    this.keys = keys;\r\n    this._keysMap = {};\r\n    keys.forEach((key, idx) => {\r\n      this._keysMap[key.id] = idx;\r\n    });\r\n  }\r\n  create() {\r\n    if (this.isCreated || !this.docs.length) {\r\n      return\r\n    }\r\n\r\n    this.isCreated = true;\r\n\r\n    // List is Array<String>\r\n    if (isString(this.docs[0])) {\r\n      this.docs.forEach((doc, docIndex) => {\r\n        this._addString(doc, docIndex);\r\n      });\r\n    } else {\r\n      // List is Array<Object>\r\n      this.docs.forEach((doc, docIndex) => {\r\n        this._addObject(doc, docIndex);\r\n      });\r\n    }\r\n\r\n    this.norm.clear();\r\n  }\r\n  // Adds a doc to the end of the index\r\n  add(doc) {\r\n    const idx = this.size();\r\n\r\n    if (isString(doc)) {\r\n      this._addString(doc, idx);\r\n    } else {\r\n      this._addObject(doc, idx);\r\n    }\r\n  }\r\n  // Removes the doc at the specified index of the index\r\n  removeAt(idx) {\r\n    this.records.splice(idx, 1);\r\n\r\n    // Change ref index of every subsquent doc\r\n    for (let i = idx, len = this.size(); i < len; i += 1) {\r\n      this.records[i].i -= 1;\r\n    }\r\n  }\r\n  getValueForItemAtKeyId(item, keyId) {\r\n    return item[this._keysMap[keyId]]\r\n  }\r\n  size() {\r\n    return this.records.length\r\n  }\r\n  _addString(doc, docIndex) {\r\n    if (!isDefined(doc) || isBlank(doc)) {\r\n      return\r\n    }\r\n\r\n    let record = {\r\n      v: doc,\r\n      i: docIndex,\r\n      n: this.norm.get(doc)\r\n    };\r\n\r\n    this.records.push(record);\r\n  }\r\n  _addObject(doc, docIndex) {\r\n    let record = { i: docIndex, $: {} };\r\n\r\n    // Iterate over every key (i.e, path), and fetch the value at that key\r\n    this.keys.forEach((key, keyIndex) => {\r\n      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\r\n\r\n      if (!isDefined(value)) {\r\n        return\r\n      }\r\n\r\n      if (isArray(value)) {\r\n        let subRecords = [];\r\n        const stack = [{ nestedArrIndex: -1, value }];\r\n\r\n        while (stack.length) {\r\n          const { nestedArrIndex, value } = stack.pop();\r\n\r\n          if (!isDefined(value)) {\r\n            continue\r\n          }\r\n\r\n          if (isString(value) && !isBlank(value)) {\r\n            let subRecord = {\r\n              v: value,\r\n              i: nestedArrIndex,\r\n              n: this.norm.get(value)\r\n            };\r\n\r\n            subRecords.push(subRecord);\r\n          } else if (isArray(value)) {\r\n            value.forEach((item, k) => {\r\n              stack.push({\r\n                nestedArrIndex: k,\r\n                value: item\r\n              });\r\n            });\r\n          } else ;\r\n        }\r\n        record.$[keyIndex] = subRecords;\r\n      } else if (isString(value) && !isBlank(value)) {\r\n        let subRecord = {\r\n          v: value,\r\n          n: this.norm.get(value)\r\n        };\r\n\r\n        record.$[keyIndex] = subRecord;\r\n      }\r\n    });\r\n\r\n    this.records.push(record);\r\n  }\r\n  toJSON() {\r\n    return {\r\n      keys: this.keys,\r\n      records: this.records\r\n    }\r\n  }\r\n}\r\n\r\nfunction createIndex(\r\n  keys,\r\n  docs,\r\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\r\n) {\r\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\r\n  myIndex.setKeys(keys.map(createKey));\r\n  myIndex.setSources(docs);\r\n  myIndex.create();\r\n  return myIndex\r\n}\r\n\r\nfunction parseIndex(\r\n  data,\r\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\r\n) {\r\n  const { keys, records } = data;\r\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\r\n  myIndex.setKeys(keys);\r\n  myIndex.setIndexRecords(records);\r\n  return myIndex\r\n}\r\n\r\nfunction computeScore$1(\r\n  pattern,\r\n  {\r\n    errors = 0,\r\n    currentLocation = 0,\r\n    expectedLocation = 0,\r\n    distance = Config.distance,\r\n    ignoreLocation = Config.ignoreLocation\r\n  } = {}\r\n) {\r\n  const accuracy = errors / pattern.length;\r\n\r\n  if (ignoreLocation) {\r\n    return accuracy\r\n  }\r\n\r\n  const proximity = Math.abs(expectedLocation - currentLocation);\r\n\r\n  if (!distance) {\r\n    // Dodge divide by zero error.\r\n    return proximity ? 1.0 : accuracy\r\n  }\r\n\r\n  return accuracy + proximity / distance\r\n}\r\n\r\nfunction convertMaskToIndices(\r\n  matchmask = [],\r\n  minMatchCharLength = Config.minMatchCharLength\r\n) {\r\n  let indices = [];\r\n  let start = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n\r\n  for (let len = matchmask.length; i < len; i += 1) {\r\n    let match = matchmask[i];\r\n    if (match && start === -1) {\r\n      start = i;\r\n    } else if (!match && start !== -1) {\r\n      end = i - 1;\r\n      if (end - start + 1 >= minMatchCharLength) {\r\n        indices.push([start, end]);\r\n      }\r\n      start = -1;\r\n    }\r\n  }\r\n\r\n  // (i-1 - start) + 1 => i - start\r\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\r\n    indices.push([start, i - 1]);\r\n  }\r\n\r\n  return indices\r\n}\r\n\r\n// Machine word size\r\nconst MAX_BITS = 32;\r\n\r\nfunction search(\r\n  text,\r\n  pattern,\r\n  patternAlphabet,\r\n  {\r\n    location = Config.location,\r\n    distance = Config.distance,\r\n    threshold = Config.threshold,\r\n    findAllMatches = Config.findAllMatches,\r\n    minMatchCharLength = Config.minMatchCharLength,\r\n    includeMatches = Config.includeMatches,\r\n    ignoreLocation = Config.ignoreLocation\r\n  } = {}\r\n) {\r\n  if (pattern.length > MAX_BITS) {\r\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))\r\n  }\r\n\r\n  const patternLen = pattern.length;\r\n  // Set starting location at beginning text and initialize the alphabet.\r\n  const textLen = text.length;\r\n  // Handle the case when location > text.length\r\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\r\n  // Highest score beyond which we give up.\r\n  let currentThreshold = threshold;\r\n  // Is there a nearby exact match? (speedup)\r\n  let bestLocation = expectedLocation;\r\n\r\n  // Performance: only computer matches when the minMatchCharLength > 1\r\n  // OR if `includeMatches` is true.\r\n  const computeMatches = minMatchCharLength > 1 || includeMatches;\r\n  // A mask of the matches, used for building the indices\r\n  const matchMask = computeMatches ? Array(textLen) : [];\r\n\r\n  let index;\r\n\r\n  // Get all exact matches, here for speed up\r\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\r\n    let score = computeScore$1(pattern, {\r\n      currentLocation: index,\r\n      expectedLocation,\r\n      distance,\r\n      ignoreLocation\r\n    });\r\n\r\n    currentThreshold = Math.min(score, currentThreshold);\r\n    bestLocation = index + patternLen;\r\n\r\n    if (computeMatches) {\r\n      let i = 0;\r\n      while (i < patternLen) {\r\n        matchMask[index + i] = 1;\r\n        i += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reset the best location\r\n  bestLocation = -1;\r\n\r\n  let lastBitArr = [];\r\n  let finalScore = 1;\r\n  let binMax = patternLen + textLen;\r\n\r\n  const mask = 1 << (patternLen - 1);\r\n\r\n  for (let i = 0; i < patternLen; i += 1) {\r\n    // Scan for the best match; each iteration allows for one more error.\r\n    // Run a binary search to determine how far from the match location we can stray\r\n    // at this error level.\r\n    let binMin = 0;\r\n    let binMid = binMax;\r\n\r\n    while (binMin < binMid) {\r\n      const score = computeScore$1(pattern, {\r\n        errors: i,\r\n        currentLocation: expectedLocation + binMid,\r\n        expectedLocation,\r\n        distance,\r\n        ignoreLocation\r\n      });\r\n\r\n      if (score <= currentThreshold) {\r\n        binMin = binMid;\r\n      } else {\r\n        binMax = binMid;\r\n      }\r\n\r\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\r\n    }\r\n\r\n    // Use the result from this iteration as the maximum for the next.\r\n    binMax = binMid;\r\n\r\n    let start = Math.max(1, expectedLocation - binMid + 1);\r\n    let finish = findAllMatches\r\n      ? textLen\r\n      : Math.min(expectedLocation + binMid, textLen) + patternLen;\r\n\r\n    // Initialize the bit array\r\n    let bitArr = Array(finish + 2);\r\n\r\n    bitArr[finish + 1] = (1 << i) - 1;\r\n\r\n    for (let j = finish; j >= start; j -= 1) {\r\n      let currentLocation = j - 1;\r\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\r\n\r\n      if (computeMatches) {\r\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\r\n        matchMask[currentLocation] = +!!charMatch;\r\n      }\r\n\r\n      // First pass: exact match\r\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;\r\n\r\n      // Subsequent passes: fuzzy match\r\n      if (i) {\r\n        bitArr[j] |=\r\n          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];\r\n      }\r\n\r\n      if (bitArr[j] & mask) {\r\n        finalScore = computeScore$1(pattern, {\r\n          errors: i,\r\n          currentLocation,\r\n          expectedLocation,\r\n          distance,\r\n          ignoreLocation\r\n        });\r\n\r\n        // This match will almost certainly be better than any existing match.\r\n        // But check anyway.\r\n        if (finalScore <= currentThreshold) {\r\n          // Indeed it is\r\n          currentThreshold = finalScore;\r\n          bestLocation = currentLocation;\r\n\r\n          // Already passed `loc`, downhill from here on in.\r\n          if (bestLocation <= expectedLocation) {\r\n            break\r\n          }\r\n\r\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\r\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\r\n        }\r\n      }\r\n    }\r\n\r\n    // No hope for a (better) match at greater error levels.\r\n    const score = computeScore$1(pattern, {\r\n      errors: i + 1,\r\n      currentLocation: expectedLocation,\r\n      expectedLocation,\r\n      distance,\r\n      ignoreLocation\r\n    });\r\n\r\n    if (score > currentThreshold) {\r\n      break\r\n    }\r\n\r\n    lastBitArr = bitArr;\r\n  }\r\n\r\n  const result = {\r\n    isMatch: bestLocation >= 0,\r\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\r\n    score: Math.max(0.001, finalScore)\r\n  };\r\n\r\n  if (computeMatches) {\r\n    const indices = convertMaskToIndices(matchMask, minMatchCharLength);\r\n    if (!indices.length) {\r\n      result.isMatch = false;\r\n    } else if (includeMatches) {\r\n      result.indices = indices;\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nfunction createPatternAlphabet(pattern) {\r\n  let mask = {};\r\n\r\n  for (let i = 0, len = pattern.length; i < len; i += 1) {\r\n    const char = pattern.charAt(i);\r\n    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));\r\n  }\r\n\r\n  return mask\r\n}\r\n\r\nclass BitapSearch {\r\n  constructor(\r\n    pattern,\r\n    {\r\n      location = Config.location,\r\n      threshold = Config.threshold,\r\n      distance = Config.distance,\r\n      includeMatches = Config.includeMatches,\r\n      findAllMatches = Config.findAllMatches,\r\n      minMatchCharLength = Config.minMatchCharLength,\r\n      isCaseSensitive = Config.isCaseSensitive,\r\n      ignoreLocation = Config.ignoreLocation\r\n    } = {}\r\n  ) {\r\n    this.options = {\r\n      location,\r\n      threshold,\r\n      distance,\r\n      includeMatches,\r\n      findAllMatches,\r\n      minMatchCharLength,\r\n      isCaseSensitive,\r\n      ignoreLocation\r\n    };\r\n\r\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\r\n\r\n    this.chunks = [];\r\n\r\n    if (!this.pattern.length) {\r\n      return\r\n    }\r\n\r\n    const addChunk = (pattern, startIndex) => {\r\n      this.chunks.push({\r\n        pattern,\r\n        alphabet: createPatternAlphabet(pattern),\r\n        startIndex\r\n      });\r\n    };\r\n\r\n    const len = this.pattern.length;\r\n\r\n    if (len > MAX_BITS) {\r\n      let i = 0;\r\n      const remainder = len % MAX_BITS;\r\n      const end = len - remainder;\r\n\r\n      while (i < end) {\r\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\r\n        i += MAX_BITS;\r\n      }\r\n\r\n      if (remainder) {\r\n        const startIndex = len - MAX_BITS;\r\n        addChunk(this.pattern.substr(startIndex), startIndex);\r\n      }\r\n    } else {\r\n      addChunk(this.pattern, 0);\r\n    }\r\n  }\r\n\r\n  searchIn(text) {\r\n    const { isCaseSensitive, includeMatches } = this.options;\r\n\r\n    if (!isCaseSensitive) {\r\n      text = text.toLowerCase();\r\n    }\r\n\r\n    // Exact match\r\n    if (this.pattern === text) {\r\n      let result = {\r\n        isMatch: true,\r\n        score: 0\r\n      };\r\n\r\n      if (includeMatches) {\r\n        result.indices = [[0, text.length - 1]];\r\n      }\r\n\r\n      return result\r\n    }\r\n\r\n    // Otherwise, use Bitap algorithm\r\n    const {\r\n      location,\r\n      distance,\r\n      threshold,\r\n      findAllMatches,\r\n      minMatchCharLength,\r\n      ignoreLocation\r\n    } = this.options;\r\n\r\n    let allIndices = [];\r\n    let totalScore = 0;\r\n    let hasMatches = false;\r\n\r\n    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {\r\n      const { isMatch, score, indices } = search(text, pattern, alphabet, {\r\n        location: location + startIndex,\r\n        distance,\r\n        threshold,\r\n        findAllMatches,\r\n        minMatchCharLength,\r\n        includeMatches,\r\n        ignoreLocation\r\n      });\r\n\r\n      if (isMatch) {\r\n        hasMatches = true;\r\n      }\r\n\r\n      totalScore += score;\r\n\r\n      if (isMatch && indices) {\r\n        allIndices = [...allIndices, ...indices];\r\n      }\r\n    });\r\n\r\n    let result = {\r\n      isMatch: hasMatches,\r\n      score: hasMatches ? totalScore / this.chunks.length : 1\r\n    };\r\n\r\n    if (hasMatches && includeMatches) {\r\n      result.indices = allIndices;\r\n    }\r\n\r\n    return result\r\n  }\r\n}\r\n\r\nclass BaseMatch {\r\n  constructor(pattern) {\r\n    this.pattern = pattern;\r\n  }\r\n  static isMultiMatch(pattern) {\r\n    return getMatch(pattern, this.multiRegex)\r\n  }\r\n  static isSingleMatch(pattern) {\r\n    return getMatch(pattern, this.singleRegex)\r\n  }\r\n  search(/*text*/) {}\r\n}\r\n\r\nfunction getMatch(pattern, exp) {\r\n  const matches = pattern.match(exp);\r\n  return matches ? matches[1] : null\r\n}\r\n\r\n// Token: 'file\r\n\r\nclass ExactMatch extends BaseMatch {\r\n  constructor(pattern) {\r\n    super(pattern);\r\n  }\r\n  static get type() {\r\n    return 'exact'\r\n  }\r\n  static get multiRegex() {\r\n    return /^=\"(.*)\"$/\r\n  }\r\n  static get singleRegex() {\r\n    return /^=(.*)$/\r\n  }\r\n  search(text) {\r\n    const isMatch = text === this.pattern;\r\n\r\n    return {\r\n      isMatch,\r\n      score: isMatch ? 0 : 1,\r\n      indices: [0, this.pattern.length - 1]\r\n    }\r\n  }\r\n}\r\n\r\n// Token: !fire\r\n\r\nclass InverseExactMatch extends BaseMatch {\r\n  constructor(pattern) {\r\n    super(pattern);\r\n  }\r\n  static get type() {\r\n    return 'inverse-exact'\r\n  }\r\n  static get multiRegex() {\r\n    return /^!\"(.*)\"$/\r\n  }\r\n  static get singleRegex() {\r\n    return /^!(.*)$/\r\n  }\r\n  search(text) {\r\n    const index = text.indexOf(this.pattern);\r\n    const isMatch = index === -1;\r\n\r\n    return {\r\n      isMatch,\r\n      score: isMatch ? 0 : 1,\r\n      indices: [0, text.length - 1]\r\n    }\r\n  }\r\n}\r\n\r\n// Token: ^file\r\n\r\nclass PrefixExactMatch extends BaseMatch {\r\n  constructor(pattern) {\r\n    super(pattern);\r\n  }\r\n  static get type() {\r\n    return 'prefix-exact'\r\n  }\r\n  static get multiRegex() {\r\n    return /^\\^\"(.*)\"$/\r\n  }\r\n  static get singleRegex() {\r\n    return /^\\^(.*)$/\r\n  }\r\n  search(text) {\r\n    const isMatch = text.startsWith(this.pattern);\r\n\r\n    return {\r\n      isMatch,\r\n      score: isMatch ? 0 : 1,\r\n      indices: [0, this.pattern.length - 1]\r\n    }\r\n  }\r\n}\r\n\r\n// Token: !^fire\r\n\r\nclass InversePrefixExactMatch extends BaseMatch {\r\n  constructor(pattern) {\r\n    super(pattern);\r\n  }\r\n  static get type() {\r\n    return 'inverse-prefix-exact'\r\n  }\r\n  static get multiRegex() {\r\n    return /^!\\^\"(.*)\"$/\r\n  }\r\n  static get singleRegex() {\r\n    return /^!\\^(.*)$/\r\n  }\r\n  search(text) {\r\n    const isMatch = !text.startsWith(this.pattern);\r\n\r\n    return {\r\n      isMatch,\r\n      score: isMatch ? 0 : 1,\r\n      indices: [0, text.length - 1]\r\n    }\r\n  }\r\n}\r\n\r\n// Token: .file$\r\n\r\nclass SuffixExactMatch extends BaseMatch {\r\n  constructor(pattern) {\r\n    super(pattern);\r\n  }\r\n  static get type() {\r\n    return 'suffix-exact'\r\n  }\r\n  static get multiRegex() {\r\n    return /^\"(.*)\"\\$$/\r\n  }\r\n  static get singleRegex() {\r\n    return /^(.*)\\$$/\r\n  }\r\n  search(text) {\r\n    const isMatch = text.endsWith(this.pattern);\r\n\r\n    return {\r\n      isMatch,\r\n      score: isMatch ? 0 : 1,\r\n      indices: [text.length - this.pattern.length, text.length - 1]\r\n    }\r\n  }\r\n}\r\n\r\n// Token: !.file$\r\n\r\nclass InverseSuffixExactMatch extends BaseMatch {\r\n  constructor(pattern) {\r\n    super(pattern);\r\n  }\r\n  static get type() {\r\n    return 'inverse-suffix-exact'\r\n  }\r\n  static get multiRegex() {\r\n    return /^!\"(.*)\"\\$$/\r\n  }\r\n  static get singleRegex() {\r\n    return /^!(.*)\\$$/\r\n  }\r\n  search(text) {\r\n    const isMatch = !text.endsWith(this.pattern);\r\n    return {\r\n      isMatch,\r\n      score: isMatch ? 0 : 1,\r\n      indices: [0, text.length - 1]\r\n    }\r\n  }\r\n}\r\n\r\nclass FuzzyMatch extends BaseMatch {\r\n  constructor(\r\n    pattern,\r\n    {\r\n      location = Config.location,\r\n      threshold = Config.threshold,\r\n      distance = Config.distance,\r\n      includeMatches = Config.includeMatches,\r\n      findAllMatches = Config.findAllMatches,\r\n      minMatchCharLength = Config.minMatchCharLength,\r\n      isCaseSensitive = Config.isCaseSensitive,\r\n      ignoreLocation = Config.ignoreLocation\r\n    } = {}\r\n  ) {\r\n    super(pattern);\r\n    this._bitapSearch = new BitapSearch(pattern, {\r\n      location,\r\n      threshold,\r\n      distance,\r\n      includeMatches,\r\n      findAllMatches,\r\n      minMatchCharLength,\r\n      isCaseSensitive,\r\n      ignoreLocation\r\n    });\r\n  }\r\n  static get type() {\r\n    return 'fuzzy'\r\n  }\r\n  static get multiRegex() {\r\n    return /^\"(.*)\"$/\r\n  }\r\n  static get singleRegex() {\r\n    return /^(.*)$/\r\n  }\r\n  search(text) {\r\n    return this._bitapSearch.searchIn(text)\r\n  }\r\n}\r\n\r\n// Token: 'file\r\n\r\nclass IncludeMatch extends BaseMatch {\r\n  constructor(pattern) {\r\n    super(pattern);\r\n  }\r\n  static get type() {\r\n    return 'include'\r\n  }\r\n  static get multiRegex() {\r\n    return /^'\"(.*)\"$/\r\n  }\r\n  static get singleRegex() {\r\n    return /^'(.*)$/\r\n  }\r\n  search(text) {\r\n    let location = 0;\r\n    let index;\r\n\r\n    const indices = [];\r\n    const patternLen = this.pattern.length;\r\n\r\n    // Get all exact matches\r\n    while ((index = text.indexOf(this.pattern, location)) > -1) {\r\n      location = index + patternLen;\r\n      indices.push([index, location - 1]);\r\n    }\r\n\r\n    const isMatch = !!indices.length;\r\n\r\n    return {\r\n      isMatch,\r\n      score: isMatch ? 0 : 1,\r\n      indices\r\n    }\r\n  }\r\n}\r\n\r\n// ❗Order is important. DO NOT CHANGE.\r\nconst searchers = [\r\n  ExactMatch,\r\n  IncludeMatch,\r\n  PrefixExactMatch,\r\n  InversePrefixExactMatch,\r\n  InverseSuffixExactMatch,\r\n  SuffixExactMatch,\r\n  InverseExactMatch,\r\n  FuzzyMatch\r\n];\r\n\r\nconst searchersLen = searchers.length;\r\n\r\n// Regex to split by spaces, but keep anything in quotes together\r\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\r\nconst OR_TOKEN = '|';\r\n\r\n// Return a 2D array representation of the query, for simpler parsing.\r\n// Example:\r\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\r\nfunction parseQuery(pattern, options = {}) {\r\n  return pattern.split(OR_TOKEN).map((item) => {\r\n    let query = item\r\n      .trim()\r\n      .split(SPACE_RE)\r\n      .filter((item) => item && !!item.trim());\r\n\r\n    let results = [];\r\n    for (let i = 0, len = query.length; i < len; i += 1) {\r\n      const queryItem = query[i];\r\n\r\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\r\n      let found = false;\r\n      let idx = -1;\r\n      while (!found && ++idx < searchersLen) {\r\n        const searcher = searchers[idx];\r\n        let token = searcher.isMultiMatch(queryItem);\r\n        if (token) {\r\n          results.push(new searcher(token, options));\r\n          found = true;\r\n        }\r\n      }\r\n\r\n      if (found) {\r\n        continue\r\n      }\r\n\r\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\r\n      idx = -1;\r\n      while (++idx < searchersLen) {\r\n        const searcher = searchers[idx];\r\n        let token = searcher.isSingleMatch(queryItem);\r\n        if (token) {\r\n          results.push(new searcher(token, options));\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    return results\r\n  })\r\n}\r\n\r\n// These extended matchers can return an array of matches, as opposed\r\n// to a singl match\r\nconst MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\r\n\r\n/**\r\n * Command-like searching\r\n * ======================\r\n *\r\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\r\n * search in a given text.\r\n *\r\n * Search syntax:\r\n *\r\n * | Token       | Match type                 | Description                            |\r\n * | ----------- | -------------------------- | -------------------------------------- |\r\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\r\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\r\n * | `'python`   | include-match              | Items that include `python`            |\r\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\r\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\r\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\r\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\r\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\r\n *\r\n * A single pipe character acts as an OR operator. For example, the following\r\n * query matches entries that start with `core` and end with either`go`, `rb`,\r\n * or`py`.\r\n *\r\n * ```\r\n * ^core go$ | rb$ | py$\r\n * ```\r\n */\r\nclass ExtendedSearch {\r\n  constructor(\r\n    pattern,\r\n    {\r\n      isCaseSensitive = Config.isCaseSensitive,\r\n      includeMatches = Config.includeMatches,\r\n      minMatchCharLength = Config.minMatchCharLength,\r\n      ignoreLocation = Config.ignoreLocation,\r\n      findAllMatches = Config.findAllMatches,\r\n      location = Config.location,\r\n      threshold = Config.threshold,\r\n      distance = Config.distance\r\n    } = {}\r\n  ) {\r\n    this.query = null;\r\n    this.options = {\r\n      isCaseSensitive,\r\n      includeMatches,\r\n      minMatchCharLength,\r\n      findAllMatches,\r\n      ignoreLocation,\r\n      location,\r\n      threshold,\r\n      distance\r\n    };\r\n\r\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\r\n    this.query = parseQuery(this.pattern, this.options);\r\n  }\r\n\r\n  static condition(_, options) {\r\n    return options.useExtendedSearch\r\n  }\r\n\r\n  searchIn(text) {\r\n    const query = this.query;\r\n\r\n    if (!query) {\r\n      return {\r\n        isMatch: false,\r\n        score: 1\r\n      }\r\n    }\r\n\r\n    const { includeMatches, isCaseSensitive } = this.options;\r\n\r\n    text = isCaseSensitive ? text : text.toLowerCase();\r\n\r\n    let numMatches = 0;\r\n    let allIndices = [];\r\n    let totalScore = 0;\r\n\r\n    // ORs\r\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\r\n      const searchers = query[i];\r\n\r\n      // Reset indices\r\n      allIndices.length = 0;\r\n      numMatches = 0;\r\n\r\n      // ANDs\r\n      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {\r\n        const searcher = searchers[j];\r\n        const { isMatch, indices, score } = searcher.search(text);\r\n\r\n        if (isMatch) {\r\n          numMatches += 1;\r\n          totalScore += score;\r\n          if (includeMatches) {\r\n            const type = searcher.constructor.type;\r\n            if (MultiMatchSet.has(type)) {\r\n              allIndices = [...allIndices, ...indices];\r\n            } else {\r\n              allIndices.push(indices);\r\n            }\r\n          }\r\n        } else {\r\n          totalScore = 0;\r\n          numMatches = 0;\r\n          allIndices.length = 0;\r\n          break\r\n        }\r\n      }\r\n\r\n      // OR condition, so if TRUE, return\r\n      if (numMatches) {\r\n        let result = {\r\n          isMatch: true,\r\n          score: totalScore / numMatches\r\n        };\r\n\r\n        if (includeMatches) {\r\n          result.indices = allIndices;\r\n        }\r\n\r\n        return result\r\n      }\r\n    }\r\n\r\n    // Nothing was matched\r\n    return {\r\n      isMatch: false,\r\n      score: 1\r\n    }\r\n  }\r\n}\r\n\r\nconst registeredSearchers = [];\r\n\r\nfunction register(...args) {\r\n  registeredSearchers.push(...args);\r\n}\r\n\r\nfunction createSearcher(pattern, options) {\r\n  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\r\n    let searcherClass = registeredSearchers[i];\r\n    if (searcherClass.condition(pattern, options)) {\r\n      return new searcherClass(pattern, options)\r\n    }\r\n  }\r\n\r\n  return new BitapSearch(pattern, options)\r\n}\r\n\r\nconst LogicalOperator = {\r\n  AND: '$and',\r\n  OR: '$or'\r\n};\r\n\r\nconst KeyType = {\r\n  PATH: '$path',\r\n  PATTERN: '$val'\r\n};\r\n\r\nconst isExpression = (query) =>\r\n  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\r\n\r\nconst isPath = (query) => !!query[KeyType.PATH];\r\n\r\nconst isLeaf = (query) =>\r\n  !isArray(query) && isObject(query) && !isExpression(query);\r\n\r\nconst convertToExplicit = (query) => ({\r\n  [LogicalOperator.AND]: Object.keys(query).map((key) => ({\r\n    [key]: query[key]\r\n  }))\r\n});\r\n\r\n// When `auto` is `true`, the parse function will infer and initialize and add\r\n// the appropriate `Searcher` instance\r\nfunction parse(query, options, { auto = true } = {}) {\r\n  const next = (query) => {\r\n    let keys = Object.keys(query);\r\n\r\n    const isQueryPath = isPath(query);\r\n\r\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\r\n      return next(convertToExplicit(query))\r\n    }\r\n\r\n    if (isLeaf(query)) {\r\n      const key = isQueryPath ? query[KeyType.PATH] : keys[0];\r\n\r\n      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\r\n\r\n      if (!isString(pattern)) {\r\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))\r\n      }\r\n\r\n      const obj = {\r\n        keyId: createKeyId(key),\r\n        pattern\r\n      };\r\n\r\n      if (auto) {\r\n        obj.searcher = createSearcher(pattern, options);\r\n      }\r\n\r\n      return obj\r\n    }\r\n\r\n    let node = {\r\n      children: [],\r\n      operator: keys[0]\r\n    };\r\n\r\n    keys.forEach((key) => {\r\n      const value = query[key];\r\n\r\n      if (isArray(value)) {\r\n        value.forEach((item) => {\r\n          node.children.push(next(item));\r\n        });\r\n      }\r\n    });\r\n\r\n    return node\r\n  };\r\n\r\n  if (!isExpression(query)) {\r\n    query = convertToExplicit(query);\r\n  }\r\n\r\n  return next(query)\r\n}\r\n\r\n// Practical scoring function\r\nfunction computeScore(\r\n  results,\r\n  { ignoreFieldNorm = Config.ignoreFieldNorm }\r\n) {\r\n  results.forEach((result) => {\r\n    let totalScore = 1;\r\n\r\n    result.matches.forEach(({ key, norm, score }) => {\r\n      const weight = key ? key.weight : null;\r\n\r\n      totalScore *= Math.pow(\r\n        score === 0 && weight ? Number.EPSILON : score,\r\n        (weight || 1) * (ignoreFieldNorm ? 1 : norm)\r\n      );\r\n    });\r\n\r\n    result.score = totalScore;\r\n  });\r\n}\r\n\r\nfunction transformMatches(result, data) {\r\n  const matches = result.matches;\r\n  data.matches = [];\r\n\r\n  if (!isDefined(matches)) {\r\n    return\r\n  }\r\n\r\n  matches.forEach((match) => {\r\n    if (!isDefined(match.indices) || !match.indices.length) {\r\n      return\r\n    }\r\n\r\n    const { indices, value } = match;\r\n\r\n    let obj = {\r\n      indices,\r\n      value\r\n    };\r\n\r\n    if (match.key) {\r\n      obj.key = match.key.src;\r\n    }\r\n\r\n    if (match.idx > -1) {\r\n      obj.refIndex = match.idx;\r\n    }\r\n\r\n    data.matches.push(obj);\r\n  });\r\n}\r\n\r\nfunction transformScore(result, data) {\r\n  data.score = result.score;\r\n}\r\n\r\nfunction format(\r\n  results,\r\n  docs,\r\n  {\r\n    includeMatches = Config.includeMatches,\r\n    includeScore = Config.includeScore\r\n  } = {}\r\n) {\r\n  const transformers = [];\r\n\r\n  if (includeMatches) transformers.push(transformMatches);\r\n  if (includeScore) transformers.push(transformScore);\r\n\r\n  return results.map((result) => {\r\n    const { idx } = result;\r\n\r\n    const data = {\r\n      item: docs[idx],\r\n      refIndex: idx\r\n    };\r\n\r\n    if (transformers.length) {\r\n      transformers.forEach((transformer) => {\r\n        transformer(result, data);\r\n      });\r\n    }\r\n\r\n    return data\r\n  })\r\n}\r\n\r\nclass Fuse {\r\n  constructor(docs, options = {}, index) {\r\n    this.options = { ...Config, ...options };\r\n\r\n    if (\r\n      this.options.useExtendedSearch &&\r\n      !true\r\n    ) {\r\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE)\r\n    }\r\n\r\n    this._keyStore = new KeyStore(this.options.keys);\r\n\r\n    this.setCollection(docs, index);\r\n  }\r\n\r\n  setCollection(docs, index) {\r\n    this._docs = docs;\r\n\r\n    if (index && !(index instanceof FuseIndex)) {\r\n      throw new Error(INCORRECT_INDEX_TYPE)\r\n    }\r\n\r\n    this._myIndex =\r\n      index ||\r\n      createIndex(this.options.keys, this._docs, {\r\n        getFn: this.options.getFn,\r\n        fieldNormWeight: this.options.fieldNormWeight\r\n      });\r\n  }\r\n\r\n  add(doc) {\r\n    if (!isDefined(doc)) {\r\n      return\r\n    }\r\n\r\n    this._docs.push(doc);\r\n    this._myIndex.add(doc);\r\n  }\r\n\r\n  remove(predicate = (/* doc, idx */) => false) {\r\n    const results = [];\r\n\r\n    for (let i = 0, len = this._docs.length; i < len; i += 1) {\r\n      const doc = this._docs[i];\r\n      if (predicate(doc, i)) {\r\n        this.removeAt(i);\r\n        i -= 1;\r\n        len -= 1;\r\n\r\n        results.push(doc);\r\n      }\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n  removeAt(idx) {\r\n    this._docs.splice(idx, 1);\r\n    this._myIndex.removeAt(idx);\r\n  }\r\n\r\n  getIndex() {\r\n    return this._myIndex\r\n  }\r\n\r\n  search(query, { limit = -1 } = {}) {\r\n    const {\r\n      includeMatches,\r\n      includeScore,\r\n      shouldSort,\r\n      sortFn,\r\n      ignoreFieldNorm\r\n    } = this.options;\r\n\r\n    let results = isString(query)\r\n      ? isString(this._docs[0])\r\n        ? this._searchStringList(query)\r\n        : this._searchObjectList(query)\r\n      : this._searchLogical(query);\r\n\r\n    computeScore(results, { ignoreFieldNorm });\r\n\r\n    if (shouldSort) {\r\n      results.sort(sortFn);\r\n    }\r\n\r\n    if (isNumber(limit) && limit > -1) {\r\n      results = results.slice(0, limit);\r\n    }\r\n\r\n    return format(results, this._docs, {\r\n      includeMatches,\r\n      includeScore\r\n    })\r\n  }\r\n\r\n  _searchStringList(query) {\r\n    const searcher = createSearcher(query, this.options);\r\n    const { records } = this._myIndex;\r\n    const results = [];\r\n\r\n    // Iterate over every string in the index\r\n    records.forEach(({ v: text, i: idx, n: norm }) => {\r\n      if (!isDefined(text)) {\r\n        return\r\n      }\r\n\r\n      const { isMatch, score, indices } = searcher.searchIn(text);\r\n\r\n      if (isMatch) {\r\n        results.push({\r\n          item: text,\r\n          idx,\r\n          matches: [{ score, value: text, norm, indices }]\r\n        });\r\n      }\r\n    });\r\n\r\n    return results\r\n  }\r\n\r\n  _searchLogical(query) {\r\n\r\n    const expression = parse(query, this.options);\r\n\r\n    const evaluate = (node, item, idx) => {\r\n      if (!node.children) {\r\n        const { keyId, searcher } = node;\r\n\r\n        const matches = this._findMatches({\r\n          key: this._keyStore.get(keyId),\r\n          value: this._myIndex.getValueForItemAtKeyId(item, keyId),\r\n          searcher\r\n        });\r\n\r\n        if (matches && matches.length) {\r\n          return [\r\n            {\r\n              idx,\r\n              item,\r\n              matches\r\n            }\r\n          ]\r\n        }\r\n\r\n        return []\r\n      }\r\n\r\n      const res = [];\r\n      for (let i = 0, len = node.children.length; i < len; i += 1) {\r\n        const child = node.children[i];\r\n        const result = evaluate(child, item, idx);\r\n        if (result.length) {\r\n          res.push(...result);\r\n        } else if (node.operator === LogicalOperator.AND) {\r\n          return []\r\n        }\r\n      }\r\n      return res\r\n    };\r\n\r\n    const records = this._myIndex.records;\r\n    const resultMap = {};\r\n    const results = [];\r\n\r\n    records.forEach(({ $: item, i: idx }) => {\r\n      if (isDefined(item)) {\r\n        let expResults = evaluate(expression, item, idx);\r\n\r\n        if (expResults.length) {\r\n          // Dedupe when adding\r\n          if (!resultMap[idx]) {\r\n            resultMap[idx] = { idx, item, matches: [] };\r\n            results.push(resultMap[idx]);\r\n          }\r\n          expResults.forEach(({ matches }) => {\r\n            resultMap[idx].matches.push(...matches);\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    return results\r\n  }\r\n\r\n  _searchObjectList(query) {\r\n    const searcher = createSearcher(query, this.options);\r\n    const { keys, records } = this._myIndex;\r\n    const results = [];\r\n\r\n    // List is Array<Object>\r\n    records.forEach(({ $: item, i: idx }) => {\r\n      if (!isDefined(item)) {\r\n        return\r\n      }\r\n\r\n      let matches = [];\r\n\r\n      // Iterate over every key (i.e, path), and fetch the value at that key\r\n      keys.forEach((key, keyIndex) => {\r\n        matches.push(\r\n          ...this._findMatches({\r\n            key,\r\n            value: item[keyIndex],\r\n            searcher\r\n          })\r\n        );\r\n      });\r\n\r\n      if (matches.length) {\r\n        results.push({\r\n          idx,\r\n          item,\r\n          matches\r\n        });\r\n      }\r\n    });\r\n\r\n    return results\r\n  }\r\n  _findMatches({ key, value, searcher }) {\r\n    if (!isDefined(value)) {\r\n      return []\r\n    }\r\n\r\n    let matches = [];\r\n\r\n    if (isArray(value)) {\r\n      value.forEach(({ v: text, i: idx, n: norm }) => {\r\n        if (!isDefined(text)) {\r\n          return\r\n        }\r\n\r\n        const { isMatch, score, indices } = searcher.searchIn(text);\r\n\r\n        if (isMatch) {\r\n          matches.push({\r\n            score,\r\n            key,\r\n            value: text,\r\n            idx,\r\n            norm,\r\n            indices\r\n          });\r\n        }\r\n      });\r\n    } else {\r\n      const { v: text, n: norm } = value;\r\n\r\n      const { isMatch, score, indices } = searcher.searchIn(text);\r\n\r\n      if (isMatch) {\r\n        matches.push({ score, key, value: text, norm, indices });\r\n      }\r\n    }\r\n\r\n    return matches\r\n  }\r\n}\r\n\r\nFuse.version = '6.6.2';\r\nFuse.createIndex = createIndex;\r\nFuse.parseIndex = parseIndex;\r\nFuse.config = Config;\r\n\r\n{\r\n  Fuse.parseQuery = parse;\r\n}\r\n\r\n{\r\n  register(ExtendedSearch);\r\n}\r\n\r\nexport { Fuse as default };\r\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,OAAOA,CAACC,KAAK,EAAE;EACtB,OAAO,CAACC,KAAK,CAACF,OAAO,GACjBG,MAAM,CAACF,KAAK,CAAC,KAAK,gBAAgB,GAClCC,KAAK,CAACF,OAAO,CAACC,KAAK,CAAC;AAC1B;;AAEA;AACA,IAAMG,QAAQ,GAAG,CAAC,GAAG,CAAC;AACtB,SAASC,YAAYA,CAACJ,KAAK,EAAE;EAC3B;EACA,IAAI,OAAOA,KAAK,IAAI,QAAQ,EAAE;IAC5B,OAAOA,KAAK;EACd;EACA,IAAIK,MAAM,GAAGL,KAAK,GAAG,EAAE;EACvB,OAAOK,MAAM,IAAI,GAAG,IAAI,CAAC,GAAGL,KAAK,IAAI,CAACG,QAAQ,GAAG,IAAI,GAAGE,MAAM;AAChE;AAEA,SAASC,QAAQA,CAACN,KAAK,EAAE;EACvB,OAAOA,KAAK,IAAI,IAAI,GAAG,EAAE,GAAGI,YAAY,CAACJ,KAAK,CAAC;AACjD;AAEA,SAASO,QAAQA,CAACP,KAAK,EAAE;EACvB,OAAO,OAAOA,KAAK,KAAK,QAAQ;AAClC;AAEA,SAASQ,QAAQA,CAACR,KAAK,EAAE;EACvB,OAAO,OAAOA,KAAK,KAAK,QAAQ;AAClC;;AAEA;AACA,SAASS,SAASA,CAACT,KAAK,EAAE;EACxB,OACEA,KAAK,KAAK,IAAI,IACdA,KAAK,KAAK,KAAK,IACdU,YAAY,CAACV,KAAK,CAAC,IAAIE,MAAM,CAACF,KAAK,CAAC,IAAI,kBAAmB;AAEhE;AAEA,SAASW,QAAQA,CAACX,KAAK,EAAE;EACvB,OAAO,OAAOA,KAAK,KAAK,QAAQ;AAClC;;AAEA;AACA,SAASU,YAAYA,CAACV,KAAK,EAAE;EAC3B,OAAOW,QAAQ,CAACX,KAAK,CAAC,IAAIA,KAAK,KAAK,IAAI;AAC1C;AAEA,SAASY,SAASA,CAACZ,KAAK,EAAE;EACxB,OAAOA,KAAK,KAAKa,SAAS,IAAIb,KAAK,KAAK,IAAI;AAC9C;AAEA,SAASc,OAAOA,CAACd,KAAK,EAAE;EACtB,OAAO,CAACA,KAAK,CAACe,IAAI,CAAC,CAAC,CAACC,MAAM;AAC7B;;AAEA;AACA;AACA,SAASd,MAAMA,CAACF,KAAK,EAAE;EACrB,OAAOA,KAAK,IAAI,IAAI,GAChBA,KAAK,KAAKa,SAAS,GACjB,oBAAoB,GACpB,eAAe,GACjBI,MAAM,CAACC,SAAS,CAACZ,QAAQ,CAACa,IAAI,CAACnB,KAAK,CAAC;AAC3C;AAEA,IAAMoB,2BAA2B,GAAG,kCAAkC;AAEtE,IAAMC,oBAAoB,GAAG,wBAAwB;AAErD,IAAMC,oCAAoC,GAAG,SAAvCA,oCAAoCA,CAAIC,GAAG;EAAA,gCAAAC,MAAA,CACtBD,GAAG;AAAA,CAAE;AAEhC,IAAME,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAIC,GAAG;EAAA,wCAAAF,MAAA,CACFE,GAAG;AAAA,CAAG;AAEzC,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAIC,IAAI;EAAA,kBAAAJ,MAAA,CAAgBI,IAAI;AAAA,CAAkB;AAExE,IAAMC,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAIN,GAAG;EAAA,oCAAAC,MAAA,CACND,GAAG;AAAA,CAA8B;AAEhE,IAAMO,MAAM,GAAGb,MAAM,CAACC,SAAS,CAACa,cAAc;AAAC,IAEzCC,QAAQ;EACZ,SAAAA,SAAYC,IAAI,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAH,QAAA;IAChB,IAAI,CAACI,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;IAEjB,IAAIC,WAAW,GAAG,CAAC;IAEnBL,IAAI,CAACM,OAAO,CAAC,UAAChB,GAAG,EAAK;MACpB,IAAIiB,GAAG,GAAGC,SAAS,CAAClB,GAAG,CAAC;MAExBe,WAAW,IAAIE,GAAG,CAACE,MAAM;MAEzBR,KAAI,CAACE,KAAK,CAACO,IAAI,CAACH,GAAG,CAAC;MACpBN,KAAI,CAACG,OAAO,CAACG,GAAG,CAACI,EAAE,CAAC,GAAGJ,GAAG;MAE1BF,WAAW,IAAIE,GAAG,CAACE,MAAM;IAC3B,CAAC,CAAC;;IAEF;IACA,IAAI,CAACN,KAAK,CAACG,OAAO,CAAC,UAAChB,GAAG,EAAK;MAC1BA,GAAG,CAACmB,MAAM,IAAIJ,WAAW;IAC3B,CAAC,CAAC;EACJ;EAACO,YAAA,CAAAb,QAAA;IAAAT,GAAA;IAAAvB,KAAA,EACD,SAAA8C,IAAIC,KAAK,EAAE;MACT,OAAO,IAAI,CAACV,OAAO,CAACU,KAAK,CAAC;IAC5B;EAAC;IAAAxB,GAAA;IAAAvB,KAAA,EACD,SAAAiC,KAAA,EAAO;MACL,OAAO,IAAI,CAACG,KAAK;IACnB;EAAC;IAAAb,GAAA;IAAAvB,KAAA,EACD,SAAAgD,OAAA,EAAS;MACP,OAAOC,IAAI,CAACC,SAAS,CAAC,IAAI,CAACd,KAAK,CAAC;IACnC;EAAC;EAAA,OAAAJ,QAAA;AAAA;AAGH,SAASS,SAASA,CAAClB,GAAG,EAAE;EACtB,IAAI4B,IAAI,GAAG,IAAI;EACf,IAAIP,EAAE,GAAG,IAAI;EACb,IAAIQ,GAAG,GAAG,IAAI;EACd,IAAIV,MAAM,GAAG,CAAC;EACd,IAAIW,KAAK,GAAG,IAAI;EAEhB,IAAI9C,QAAQ,CAACgB,GAAG,CAAC,IAAIxB,OAAO,CAACwB,GAAG,CAAC,EAAE;IACjC6B,GAAG,GAAG7B,GAAG;IACT4B,IAAI,GAAGG,aAAa,CAAC/B,GAAG,CAAC;IACzBqB,EAAE,GAAGW,WAAW,CAAChC,GAAG,CAAC;EACvB,CAAC,MAAM;IACL,IAAI,CAACO,MAAM,CAACX,IAAI,CAACI,GAAG,EAAE,MAAM,CAAC,EAAE;MAC7B,MAAM,IAAIiC,KAAK,CAAC7B,oBAAoB,CAAC,MAAM,CAAC,CAAC;IAC/C;IAEA,IAAMC,IAAI,GAAGL,GAAG,CAACK,IAAI;IACrBwB,GAAG,GAAGxB,IAAI;IAEV,IAAIE,MAAM,CAACX,IAAI,CAACI,GAAG,EAAE,QAAQ,CAAC,EAAE;MAC9BmB,MAAM,GAAGnB,GAAG,CAACmB,MAAM;MAEnB,IAAIA,MAAM,IAAI,CAAC,EAAE;QACf,MAAM,IAAIc,KAAK,CAAC3B,wBAAwB,CAACD,IAAI,CAAC,CAAC;MACjD;IACF;IAEAuB,IAAI,GAAGG,aAAa,CAAC1B,IAAI,CAAC;IAC1BgB,EAAE,GAAGW,WAAW,CAAC3B,IAAI,CAAC;IACtByB,KAAK,GAAG9B,GAAG,CAAC8B,KAAK;EACnB;EAEA,OAAO;IAAEF,IAAI,EAAJA,IAAI;IAAEP,EAAE,EAAFA,EAAE;IAAEF,MAAM,EAANA,MAAM;IAAEU,GAAG,EAAHA,GAAG;IAAEC,KAAK,EAALA;EAAM,CAAC;AACzC;AAEA,SAASC,aAAaA,CAAC/B,GAAG,EAAE;EAC1B,OAAOxB,OAAO,CAACwB,GAAG,CAAC,GAAGA,GAAG,GAAGA,GAAG,CAACkC,KAAK,CAAC,GAAG,CAAC;AAC5C;AAEA,SAASF,WAAWA,CAAChC,GAAG,EAAE;EACxB,OAAOxB,OAAO,CAACwB,GAAG,CAAC,GAAGA,GAAG,CAACmC,IAAI,CAAC,GAAG,CAAC,GAAGnC,GAAG;AAC3C;AAEA,SAASuB,GAAGA,CAACN,GAAG,EAAEW,IAAI,EAAE;EACtB,IAAIQ,IAAI,GAAG,EAAE;EACb,IAAIC,GAAG,GAAG,KAAK;EAEf,IAAMC,OAAO,GAAG,SAAVA,OAAOA,CAAIrB,GAAG,EAAEW,IAAI,EAAEW,KAAK,EAAK;IACpC,IAAI,CAAClD,SAAS,CAAC4B,GAAG,CAAC,EAAE;MACnB;IACF;IACA,IAAI,CAACW,IAAI,CAACW,KAAK,CAAC,EAAE;MAChB;MACAH,IAAI,CAAChB,IAAI,CAACH,GAAG,CAAC;IAChB,CAAC,MAAM;MACL,IAAIjB,GAAG,GAAG4B,IAAI,CAACW,KAAK,CAAC;MAErB,IAAM9D,KAAK,GAAGwC,GAAG,CAACjB,GAAG,CAAC;MAEtB,IAAI,CAACX,SAAS,CAACZ,KAAK,CAAC,EAAE;QACrB;MACF;;MAEA;MACA;MACA,IACE8D,KAAK,KAAKX,IAAI,CAACnC,MAAM,GAAG,CAAC,KACxBT,QAAQ,CAACP,KAAK,CAAC,IAAIQ,QAAQ,CAACR,KAAK,CAAC,IAAIS,SAAS,CAACT,KAAK,CAAC,CAAC,EACxD;QACA2D,IAAI,CAAChB,IAAI,CAACrC,QAAQ,CAACN,KAAK,CAAC,CAAC;MAC5B,CAAC,MAAM,IAAID,OAAO,CAACC,KAAK,CAAC,EAAE;QACzB4D,GAAG,GAAG,IAAI;QACV;QACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGhE,KAAK,CAACgB,MAAM,EAAE+C,CAAC,GAAGC,GAAG,EAAED,CAAC,IAAI,CAAC,EAAE;UACnDF,OAAO,CAAC7D,KAAK,CAAC+D,CAAC,CAAC,EAAEZ,IAAI,EAAEW,KAAK,GAAG,CAAC,CAAC;QACpC;MACF,CAAC,MAAM,IAAIX,IAAI,CAACnC,MAAM,EAAE;QACtB;QACA6C,OAAO,CAAC7D,KAAK,EAAEmD,IAAI,EAAEW,KAAK,GAAG,CAAC,CAAC;MACjC;IACF;EACF,CAAC;;EAED;EACAD,OAAO,CAACrB,GAAG,EAAEjC,QAAQ,CAAC4C,IAAI,CAAC,GAAGA,IAAI,CAACM,KAAK,CAAC,GAAG,CAAC,GAAGN,IAAI,EAAE,CAAC,CAAC;EAExD,OAAOS,GAAG,GAAGD,IAAI,GAAGA,IAAI,CAAC,CAAC,CAAC;AAC7B;AAEA,IAAMM,YAAY,GAAG;EACnB;EACA;EACA;EACAC,cAAc,EAAE,KAAK;EACrB;EACA;EACAC,cAAc,EAAE,KAAK;EACrB;EACAC,kBAAkB,EAAE;AACtB,CAAC;AAED,IAAMC,YAAY,GAAG;EACnB;EACA;EACAC,eAAe,EAAE,KAAK;EACtB;EACAC,YAAY,EAAE,KAAK;EACnB;EACAtC,IAAI,EAAE,EAAE;EACR;EACAuC,UAAU,EAAE,IAAI;EAChB;EACAC,MAAM,EAAE,SAAAA,OAACC,CAAC,EAAEC,CAAC;IAAA,OACXD,CAAC,CAACE,KAAK,KAAKD,CAAC,CAACC,KAAK,GAAIF,CAAC,CAACG,GAAG,GAAGF,CAAC,CAACE,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,GAAIH,CAAC,CAACE,KAAK,GAAGD,CAAC,CAACC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC;EAAA;AAC/E,CAAC;AAED,IAAME,YAAY,GAAG;EACnB;EACAC,QAAQ,EAAE,CAAC;EACX;EACA;EACAC,SAAS,EAAE,GAAG;EACd;EACA;EACA;EACA;EACA;EACAC,QAAQ,EAAE;AACZ,CAAC;AAED,IAAMC,eAAe,GAAG;EACtB;EACAC,iBAAiB,EAAE,KAAK;EACxB;EACA;EACA9B,KAAK,EAAEP,GAAG;EACV;EACA;EACA;EACAsC,cAAc,EAAE,KAAK;EACrB;EACA;EACA;EACAC,eAAe,EAAE,KAAK;EACtB;EACAC,eAAe,EAAE;AACnB,CAAC;AAED,IAAIC,MAAM,GAAAC,aAAA,CAAAA,aAAA,CAAAA,aAAA,CAAAA,aAAA,KACLnB,YAAY,GACZJ,YAAY,GACZa,YAAY,GACZI,eAAe,CACnB;AAED,IAAMO,KAAK,GAAG,QAAQ;;AAEtB;AACA;AACA,SAASC,IAAIA,CAAA,EAA2B;EAAA,IAA1BhD,MAAM,GAAAiD,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAG,CAAC;EAAA,IAAEC,QAAQ,GAAAD,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAG,CAAC;EACpC,IAAME,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;EACvB,IAAMC,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,EAAE,EAAEL,QAAQ,CAAC;EAEhC,OAAO;IACL9C,GAAG,WAAAA,IAAC9C,KAAK,EAAE;MACT,IAAMkG,SAAS,GAAGlG,KAAK,CAACmG,KAAK,CAACV,KAAK,CAAC,CAACzE,MAAM;MAE3C,IAAI6E,KAAK,CAACO,GAAG,CAACF,SAAS,CAAC,EAAE;QACxB,OAAOL,KAAK,CAAC/C,GAAG,CAACoD,SAAS,CAAC;MAC7B;;MAEA;MACA,IAAMR,IAAI,GAAG,CAAC,GAAGM,IAAI,CAACC,GAAG,CAACC,SAAS,EAAE,GAAG,GAAGxD,MAAM,CAAC;;MAElD;MACA,IAAM2D,CAAC,GAAGC,UAAU,CAACN,IAAI,CAACO,KAAK,CAACb,IAAI,GAAGK,CAAC,CAAC,GAAGA,CAAC,CAAC;MAE9CF,KAAK,CAACW,GAAG,CAACN,SAAS,EAAEG,CAAC,CAAC;MAEvB,OAAOA,CAAC;IACV,CAAC;IACDI,KAAK,WAAAA,MAAA,EAAG;MACNZ,KAAK,CAACY,KAAK,CAAC,CAAC;IACf;EACF,CAAC;AACH;AAAC,IAEKC,SAAS;EACb,SAAAA,UAAA,EAGQ;IAAA,IAAAC,IAAA,GAAAhB,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAJ,CAAC,CAAC;MAAAiB,UAAA,GAAAD,IAAA,CAFJtD,KAAK;MAALA,KAAK,GAAAuD,UAAA,cAAGrB,MAAM,CAAClC,KAAK,GAAAuD,UAAA;MAAAC,oBAAA,GAAAF,IAAA,CACpBrB,eAAe;MAAfA,eAAe,GAAAuB,oBAAA,cAAGtB,MAAM,CAACD,eAAe,GAAAuB,oBAAA;IAAA1E,eAAA,OAAAuE,SAAA;IAExC,IAAI,CAAChB,IAAI,GAAGA,IAAI,CAACJ,eAAe,EAAE,CAAC,CAAC;IACpC,IAAI,CAACjC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACyD,SAAS,GAAG,KAAK;IAEtB,IAAI,CAACC,eAAe,CAAC,CAAC;EACxB;EAAClE,YAAA,CAAA6D,SAAA;IAAAnF,GAAA;IAAAvB,KAAA,EACD,SAAAgH,WAAA,EAAsB;MAAA,IAAXC,IAAI,GAAAtB,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAG,EAAE;MAClB,IAAI,CAACsB,IAAI,GAAGA,IAAI;IAClB;EAAC;IAAA1F,GAAA;IAAAvB,KAAA,EACD,SAAA+G,gBAAA,EAA8B;MAAA,IAAdG,OAAO,GAAAvB,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAG,EAAE;MAC1B,IAAI,CAACuB,OAAO,GAAGA,OAAO;IACxB;EAAC;IAAA3F,GAAA;IAAAvB,KAAA,EACD,SAAAmH,QAAA,EAAmB;MAAA,IAAAC,MAAA;MAAA,IAAXnF,IAAI,GAAA0D,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAG,EAAE;MACf,IAAI,CAAC1D,IAAI,GAAGA,IAAI;MAChB,IAAI,CAACoF,QAAQ,GAAG,CAAC,CAAC;MAClBpF,IAAI,CAACM,OAAO,CAAC,UAAChB,GAAG,EAAEsD,GAAG,EAAK;QACzBuC,MAAI,CAACC,QAAQ,CAAC9F,GAAG,CAACqB,EAAE,CAAC,GAAGiC,GAAG;MAC7B,CAAC,CAAC;IACJ;EAAC;IAAAtD,GAAA;IAAAvB,KAAA,EACD,SAAAsH,OAAA,EAAS;MAAA,IAAAC,MAAA;MACP,IAAI,IAAI,CAACT,SAAS,IAAI,CAAC,IAAI,CAACG,IAAI,CAACjG,MAAM,EAAE;QACvC;MACF;MAEA,IAAI,CAAC8F,SAAS,GAAG,IAAI;;MAErB;MACA,IAAIvG,QAAQ,CAAC,IAAI,CAAC0G,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;QAC1B,IAAI,CAACA,IAAI,CAAC1E,OAAO,CAAC,UAACiF,GAAG,EAAEC,QAAQ,EAAK;UACnCF,MAAI,CAACG,UAAU,CAACF,GAAG,EAAEC,QAAQ,CAAC;QAChC,CAAC,CAAC;MACJ,CAAC,MAAM;QACL;QACA,IAAI,CAACR,IAAI,CAAC1E,OAAO,CAAC,UAACiF,GAAG,EAAEC,QAAQ,EAAK;UACnCF,MAAI,CAACI,UAAU,CAACH,GAAG,EAAEC,QAAQ,CAAC;QAChC,CAAC,CAAC;MACJ;MAEA,IAAI,CAAC/B,IAAI,CAACe,KAAK,CAAC,CAAC;IACnB;IACA;EAAA;IAAAlF,GAAA;IAAAvB,KAAA,EACA,SAAA4H,IAAIJ,GAAG,EAAE;MACP,IAAM3C,GAAG,GAAG,IAAI,CAACgD,IAAI,CAAC,CAAC;MAEvB,IAAItH,QAAQ,CAACiH,GAAG,CAAC,EAAE;QACjB,IAAI,CAACE,UAAU,CAACF,GAAG,EAAE3C,GAAG,CAAC;MAC3B,CAAC,MAAM;QACL,IAAI,CAAC8C,UAAU,CAACH,GAAG,EAAE3C,GAAG,CAAC;MAC3B;IACF;IACA;EAAA;IAAAtD,GAAA;IAAAvB,KAAA,EACA,SAAA8H,SAASjD,GAAG,EAAE;MACZ,IAAI,CAACqC,OAAO,CAACa,MAAM,CAAClD,GAAG,EAAE,CAAC,CAAC;;MAE3B;MACA,KAAK,IAAId,CAAC,GAAGc,GAAG,EAAEb,GAAG,GAAG,IAAI,CAAC6D,IAAI,CAAC,CAAC,EAAE9D,CAAC,GAAGC,GAAG,EAAED,CAAC,IAAI,CAAC,EAAE;QACpD,IAAI,CAACmD,OAAO,CAACnD,CAAC,CAAC,CAACA,CAAC,IAAI,CAAC;MACxB;IACF;EAAC;IAAAxC,GAAA;IAAAvB,KAAA,EACD,SAAAgI,uBAAuBC,IAAI,EAAElF,KAAK,EAAE;MAClC,OAAOkF,IAAI,CAAC,IAAI,CAACZ,QAAQ,CAACtE,KAAK,CAAC,CAAC;IACnC;EAAC;IAAAxB,GAAA;IAAAvB,KAAA,EACD,SAAA6H,KAAA,EAAO;MACL,OAAO,IAAI,CAACX,OAAO,CAAClG,MAAM;IAC5B;EAAC;IAAAO,GAAA;IAAAvB,KAAA,EACD,SAAA0H,WAAWF,GAAG,EAAEC,QAAQ,EAAE;MACxB,IAAI,CAAC7G,SAAS,CAAC4G,GAAG,CAAC,IAAI1G,OAAO,CAAC0G,GAAG,CAAC,EAAE;QACnC;MACF;MAEA,IAAIU,MAAM,GAAG;QACXC,CAAC,EAAEX,GAAG;QACNzD,CAAC,EAAE0D,QAAQ;QACXpB,CAAC,EAAE,IAAI,CAACX,IAAI,CAAC5C,GAAG,CAAC0E,GAAG;MACtB,CAAC;MAED,IAAI,CAACN,OAAO,CAACvE,IAAI,CAACuF,MAAM,CAAC;IAC3B;EAAC;IAAA3G,GAAA;IAAAvB,KAAA,EACD,SAAA2H,WAAWH,GAAG,EAAEC,QAAQ,EAAE;MAAA,IAAAW,MAAA;MACxB,IAAIF,MAAM,GAAG;QAAEnE,CAAC,EAAE0D,QAAQ;QAAEY,CAAC,EAAE,CAAC;MAAE,CAAC;;MAEnC;MACA,IAAI,CAACpG,IAAI,CAACM,OAAO,CAAC,UAAChB,GAAG,EAAE+G,QAAQ,EAAK;QACnC,IAAItI,KAAK,GAAGuB,GAAG,CAAC8B,KAAK,GAAG9B,GAAG,CAAC8B,KAAK,CAACmE,GAAG,CAAC,GAAGY,MAAI,CAAC/E,KAAK,CAACmE,GAAG,EAAEjG,GAAG,CAAC4B,IAAI,CAAC;QAElE,IAAI,CAACvC,SAAS,CAACZ,KAAK,CAAC,EAAE;UACrB;QACF;QAEA,IAAID,OAAO,CAACC,KAAK,CAAC,EAAE;UAClB,IAAIuI,UAAU,GAAG,EAAE;UACnB,IAAMC,KAAK,GAAG,CAAC;YAAEC,cAAc,EAAE,CAAC,CAAC;YAAEzI,KAAK,EAALA;UAAM,CAAC,CAAC;UAE7C,OAAOwI,KAAK,CAACxH,MAAM,EAAE;YACnB,IAAA0H,UAAA,GAAkCF,KAAK,CAACG,GAAG,CAAC,CAAC;cAArCF,cAAc,GAAAC,UAAA,CAAdD,cAAc;cAAEzI,MAAK,GAAA0I,UAAA,CAAL1I,KAAK;YAE7B,IAAI,CAACY,SAAS,CAACZ,MAAK,CAAC,EAAE;cACrB;YACF;YAEA,IAAIO,QAAQ,CAACP,MAAK,CAAC,IAAI,CAACc,OAAO,CAACd,MAAK,CAAC,EAAE;cACtC,IAAI4I,SAAS,GAAG;gBACdT,CAAC,EAAEnI,MAAK;gBACR+D,CAAC,EAAE0E,cAAc;gBACjBpC,CAAC,EAAE+B,MAAI,CAAC1C,IAAI,CAAC5C,GAAG,CAAC9C,MAAK;cACxB,CAAC;cAEDuI,UAAU,CAAC5F,IAAI,CAACiG,SAAS,CAAC;YAC5B,CAAC,MAAM,IAAI7I,OAAO,CAACC,MAAK,CAAC,EAAE;cACzBA,MAAK,CAACuC,OAAO,CAAC,UAAC0F,IAAI,EAAEY,CAAC,EAAK;gBACzBL,KAAK,CAAC7F,IAAI,CAAC;kBACT8F,cAAc,EAAEI,CAAC;kBACjB7I,KAAK,EAAEiI;gBACT,CAAC,CAAC;cACJ,CAAC,CAAC;YACJ,CAAC,MAAM;UACT;UACAC,MAAM,CAACG,CAAC,CAACC,QAAQ,CAAC,GAAGC,UAAU;QACjC,CAAC,MAAM,IAAIhI,QAAQ,CAACP,KAAK,CAAC,IAAI,CAACc,OAAO,CAACd,KAAK,CAAC,EAAE;UAC7C,IAAI4I,UAAS,GAAG;YACdT,CAAC,EAAEnI,KAAK;YACRqG,CAAC,EAAE+B,MAAI,CAAC1C,IAAI,CAAC5C,GAAG,CAAC9C,KAAK;UACxB,CAAC;UAEDkI,MAAM,CAACG,CAAC,CAACC,QAAQ,CAAC,GAAGM,UAAS;QAChC;MACF,CAAC,CAAC;MAEF,IAAI,CAAC1B,OAAO,CAACvE,IAAI,CAACuF,MAAM,CAAC;IAC3B;EAAC;IAAA3G,GAAA;IAAAvB,KAAA,EACD,SAAAgD,OAAA,EAAS;MACP,OAAO;QACLf,IAAI,EAAE,IAAI,CAACA,IAAI;QACfiF,OAAO,EAAE,IAAI,CAACA;MAChB,CAAC;IACH;EAAC;EAAA,OAAAR,SAAA;AAAA;AAGH,SAASoC,WAAWA,CAClB7G,IAAI,EACJgF,IAAI,EAEJ;EAAA,IAAA8B,KAAA,GAAApD,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MADqE,CAAC,CAAC;IAAAqD,WAAA,GAAAD,KAAA,CAArE1F,KAAK;IAALA,KAAK,GAAA2F,WAAA,cAAGzD,MAAM,CAAClC,KAAK,GAAA2F,WAAA;IAAAC,qBAAA,GAAAF,KAAA,CAAEzD,eAAe;IAAfA,eAAe,GAAA2D,qBAAA,cAAG1D,MAAM,CAACD,eAAe,GAAA2D,qBAAA;EAEhE,IAAMC,OAAO,GAAG,IAAIxC,SAAS,CAAC;IAAErD,KAAK,EAALA,KAAK;IAAEiC,eAAe,EAAfA;EAAgB,CAAC,CAAC;EACzD4D,OAAO,CAAC/B,OAAO,CAAClF,IAAI,CAACkH,GAAG,CAAC1G,SAAS,CAAC,CAAC;EACpCyG,OAAO,CAAClC,UAAU,CAACC,IAAI,CAAC;EACxBiC,OAAO,CAAC5B,MAAM,CAAC,CAAC;EAChB,OAAO4B,OAAO;AAChB;AAEA,SAASE,UAAUA,CACjBC,IAAI,EAEJ;EAAA,IAAAC,KAAA,GAAA3D,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MADqE,CAAC,CAAC;IAAA4D,WAAA,GAAAD,KAAA,CAArEjG,KAAK;IAALA,KAAK,GAAAkG,WAAA,cAAGhE,MAAM,CAAClC,KAAK,GAAAkG,WAAA;IAAAC,qBAAA,GAAAF,KAAA,CAAEhE,eAAe;IAAfA,eAAe,GAAAkE,qBAAA,cAAGjE,MAAM,CAACD,eAAe,GAAAkE,qBAAA;EAEhE,IAAQvH,IAAI,GAAcoH,IAAI,CAAtBpH,IAAI;IAAEiF,OAAO,GAAKmC,IAAI,CAAhBnC,OAAO;EACrB,IAAMgC,OAAO,GAAG,IAAIxC,SAAS,CAAC;IAAErD,KAAK,EAALA,KAAK;IAAEiC,eAAe,EAAfA;EAAgB,CAAC,CAAC;EACzD4D,OAAO,CAAC/B,OAAO,CAAClF,IAAI,CAAC;EACrBiH,OAAO,CAACnC,eAAe,CAACG,OAAO,CAAC;EAChC,OAAOgC,OAAO;AAChB;AAEA,SAASO,cAAcA,CACrBC,OAAO,EAQP;EAAA,IAAAC,KAAA,GAAAhE,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MADI,CAAC,CAAC;IAAAiE,YAAA,GAAAD,KAAA,CALJE,MAAM;IAANA,MAAM,GAAAD,YAAA,cAAG,CAAC,GAAAA,YAAA;IAAAE,qBAAA,GAAAH,KAAA,CACVI,eAAe;IAAfA,eAAe,GAAAD,qBAAA,cAAG,CAAC,GAAAA,qBAAA;IAAAE,qBAAA,GAAAL,KAAA,CACnBM,gBAAgB;IAAhBA,gBAAgB,GAAAD,qBAAA,cAAG,CAAC,GAAAA,qBAAA;IAAAE,cAAA,GAAAP,KAAA,CACpB1E,QAAQ;IAARA,QAAQ,GAAAiF,cAAA,cAAG3E,MAAM,CAACN,QAAQ,GAAAiF,cAAA;IAAAC,oBAAA,GAAAR,KAAA,CAC1BvE,cAAc;IAAdA,cAAc,GAAA+E,oBAAA,cAAG5E,MAAM,CAACH,cAAc,GAAA+E,oBAAA;EAGxC,IAAMC,QAAQ,GAAGP,MAAM,GAAGH,OAAO,CAAC1I,MAAM;EAExC,IAAIoE,cAAc,EAAE;IAClB,OAAOgF,QAAQ;EACjB;EAEA,IAAMC,SAAS,GAAGrE,IAAI,CAACsE,GAAG,CAACL,gBAAgB,GAAGF,eAAe,CAAC;EAE9D,IAAI,CAAC9E,QAAQ,EAAE;IACb;IACA,OAAOoF,SAAS,GAAG,GAAG,GAAGD,QAAQ;EACnC;EAEA,OAAOA,QAAQ,GAAGC,SAAS,GAAGpF,QAAQ;AACxC;AAEA,SAASsF,oBAAoBA,CAAA,EAG3B;EAAA,IAFAC,SAAS,GAAA7E,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAG,EAAE;EAAA,IACdvB,kBAAkB,GAAAuB,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAGJ,MAAM,CAACnB,kBAAkB;EAE9C,IAAIqG,OAAO,GAAG,EAAE;EAChB,IAAIC,KAAK,GAAG,CAAC,CAAC;EACd,IAAIC,GAAG,GAAG,CAAC,CAAC;EACZ,IAAI5G,CAAC,GAAG,CAAC;EAET,KAAK,IAAIC,GAAG,GAAGwG,SAAS,CAACxJ,MAAM,EAAE+C,CAAC,GAAGC,GAAG,EAAED,CAAC,IAAI,CAAC,EAAE;IAChD,IAAIoC,KAAK,GAAGqE,SAAS,CAACzG,CAAC,CAAC;IACxB,IAAIoC,KAAK,IAAIuE,KAAK,KAAK,CAAC,CAAC,EAAE;MACzBA,KAAK,GAAG3G,CAAC;IACX,CAAC,MAAM,IAAI,CAACoC,KAAK,IAAIuE,KAAK,KAAK,CAAC,CAAC,EAAE;MACjCC,GAAG,GAAG5G,CAAC,GAAG,CAAC;MACX,IAAI4G,GAAG,GAAGD,KAAK,GAAG,CAAC,IAAItG,kBAAkB,EAAE;QACzCqG,OAAO,CAAC9H,IAAI,CAAC,CAAC+H,KAAK,EAAEC,GAAG,CAAC,CAAC;MAC5B;MACAD,KAAK,GAAG,CAAC,CAAC;IACZ;EACF;;EAEA;EACA,IAAIF,SAAS,CAACzG,CAAC,GAAG,CAAC,CAAC,IAAIA,CAAC,GAAG2G,KAAK,IAAItG,kBAAkB,EAAE;IACvDqG,OAAO,CAAC9H,IAAI,CAAC,CAAC+H,KAAK,EAAE3G,CAAC,GAAG,CAAC,CAAC,CAAC;EAC9B;EAEA,OAAO0G,OAAO;AAChB;;AAEA;AACA,IAAMG,QAAQ,GAAG,EAAE;AAEnB,SAASC,MAAMA,CACbC,IAAI,EACJpB,OAAO,EACPqB,eAAe,EAUf;EAAA,IAAAC,KAAA,GAAArF,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MADI,CAAC,CAAC;IAAAsF,cAAA,GAAAD,KAAA,CAPJjG,QAAQ;IAARA,QAAQ,GAAAkG,cAAA,cAAG1F,MAAM,CAACR,QAAQ,GAAAkG,cAAA;IAAAC,cAAA,GAAAF,KAAA,CAC1B/F,QAAQ;IAARA,QAAQ,GAAAiG,cAAA,cAAG3F,MAAM,CAACN,QAAQ,GAAAiG,cAAA;IAAAC,eAAA,GAAAH,KAAA,CAC1BhG,SAAS;IAATA,SAAS,GAAAmG,eAAA,cAAG5F,MAAM,CAACP,SAAS,GAAAmG,eAAA;IAAAC,oBAAA,GAAAJ,KAAA,CAC5B7G,cAAc;IAAdA,cAAc,GAAAiH,oBAAA,cAAG7F,MAAM,CAACpB,cAAc,GAAAiH,oBAAA;IAAAC,qBAAA,GAAAL,KAAA,CACtC5G,kBAAkB;IAAlBA,kBAAkB,GAAAiH,qBAAA,cAAG9F,MAAM,CAACnB,kBAAkB,GAAAiH,qBAAA;IAAAC,oBAAA,GAAAN,KAAA,CAC9C9G,cAAc;IAAdA,cAAc,GAAAoH,oBAAA,cAAG/F,MAAM,CAACrB,cAAc,GAAAoH,oBAAA;IAAAC,oBAAA,GAAAP,KAAA,CACtC5F,cAAc;IAAdA,cAAc,GAAAmG,oBAAA,cAAGhG,MAAM,CAACH,cAAc,GAAAmG,oBAAA;EAGxC,IAAI7B,OAAO,CAAC1I,MAAM,GAAG4J,QAAQ,EAAE;IAC7B,MAAM,IAAIpH,KAAK,CAAC/B,wBAAwB,CAACmJ,QAAQ,CAAC,CAAC;EACrD;EAEA,IAAMY,UAAU,GAAG9B,OAAO,CAAC1I,MAAM;EACjC;EACA,IAAMyK,OAAO,GAAGX,IAAI,CAAC9J,MAAM;EAC3B;EACA,IAAMiJ,gBAAgB,GAAGjE,IAAI,CAACtE,GAAG,CAAC,CAAC,EAAEsE,IAAI,CAAC0F,GAAG,CAAC3G,QAAQ,EAAE0G,OAAO,CAAC,CAAC;EACjE;EACA,IAAIE,gBAAgB,GAAG3G,SAAS;EAChC;EACA,IAAI4G,YAAY,GAAG3B,gBAAgB;;EAEnC;EACA;EACA,IAAM4B,cAAc,GAAGzH,kBAAkB,GAAG,CAAC,IAAIF,cAAc;EAC/D;EACA,IAAM4H,SAAS,GAAGD,cAAc,GAAG5L,KAAK,CAACwL,OAAO,CAAC,GAAG,EAAE;EAEtD,IAAI3H,KAAK;;EAET;EACA,OAAO,CAACA,KAAK,GAAGgH,IAAI,CAACiB,OAAO,CAACrC,OAAO,EAAEkC,YAAY,CAAC,IAAI,CAAC,CAAC,EAAE;IACzD,IAAIhH,KAAK,GAAG6E,cAAc,CAACC,OAAO,EAAE;MAClCK,eAAe,EAAEjG,KAAK;MACtBmG,gBAAgB,EAAhBA,gBAAgB;MAChBhF,QAAQ,EAARA,QAAQ;MACRG,cAAc,EAAdA;IACF,CAAC,CAAC;IAEFuG,gBAAgB,GAAG3F,IAAI,CAAC0F,GAAG,CAAC9G,KAAK,EAAE+G,gBAAgB,CAAC;IACpDC,YAAY,GAAG9H,KAAK,GAAG0H,UAAU;IAEjC,IAAIK,cAAc,EAAE;MAClB,IAAI9H,CAAC,GAAG,CAAC;MACT,OAAOA,CAAC,GAAGyH,UAAU,EAAE;QACrBM,SAAS,CAAChI,KAAK,GAAGC,CAAC,CAAC,GAAG,CAAC;QACxBA,CAAC,IAAI,CAAC;MACR;IACF;EACF;;EAEA;EACA6H,YAAY,GAAG,CAAC,CAAC;EAEjB,IAAII,UAAU,GAAG,EAAE;EACnB,IAAIC,UAAU,GAAG,CAAC;EAClB,IAAIC,MAAM,GAAGV,UAAU,GAAGC,OAAO;EAEjC,IAAMU,IAAI,GAAG,CAAC,IAAKX,UAAU,GAAG,CAAE;EAElC,KAAK,IAAIzH,EAAC,GAAG,CAAC,EAAEA,EAAC,GAAGyH,UAAU,EAAEzH,EAAC,IAAI,CAAC,EAAE;IACtC;IACA;IACA;IACA,IAAIqI,MAAM,GAAG,CAAC;IACd,IAAIC,MAAM,GAAGH,MAAM;IAEnB,OAAOE,MAAM,GAAGC,MAAM,EAAE;MACtB,IAAMzH,MAAK,GAAG6E,cAAc,CAACC,OAAO,EAAE;QACpCG,MAAM,EAAE9F,EAAC;QACTgG,eAAe,EAAEE,gBAAgB,GAAGoC,MAAM;QAC1CpC,gBAAgB,EAAhBA,gBAAgB;QAChBhF,QAAQ,EAARA,QAAQ;QACRG,cAAc,EAAdA;MACF,CAAC,CAAC;MAEF,IAAIR,MAAK,IAAI+G,gBAAgB,EAAE;QAC7BS,MAAM,GAAGC,MAAM;MACjB,CAAC,MAAM;QACLH,MAAM,GAAGG,MAAM;MACjB;MAEAA,MAAM,GAAGrG,IAAI,CAACsG,KAAK,CAAC,CAACJ,MAAM,GAAGE,MAAM,IAAI,CAAC,GAAGA,MAAM,CAAC;IACrD;;IAEA;IACAF,MAAM,GAAGG,MAAM;IAEf,IAAI3B,KAAK,GAAG1E,IAAI,CAACtE,GAAG,CAAC,CAAC,EAAEuI,gBAAgB,GAAGoC,MAAM,GAAG,CAAC,CAAC;IACtD,IAAIE,MAAM,GAAGpI,cAAc,GACvBsH,OAAO,GACPzF,IAAI,CAAC0F,GAAG,CAACzB,gBAAgB,GAAGoC,MAAM,EAAEZ,OAAO,CAAC,GAAGD,UAAU;;IAE7D;IACA,IAAIgB,MAAM,GAAGvM,KAAK,CAACsM,MAAM,GAAG,CAAC,CAAC;IAE9BC,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAIxI,EAAC,IAAI,CAAC;IAEjC,KAAK,IAAI0I,CAAC,GAAGF,MAAM,EAAEE,CAAC,IAAI/B,KAAK,EAAE+B,CAAC,IAAI,CAAC,EAAE;MACvC,IAAI1C,eAAe,GAAG0C,CAAC,GAAG,CAAC;MAC3B,IAAIC,SAAS,GAAG3B,eAAe,CAACD,IAAI,CAAC6B,MAAM,CAAC5C,eAAe,CAAC,CAAC;MAE7D,IAAI8B,cAAc,EAAE;QAClB;QACAC,SAAS,CAAC/B,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC2C,SAAS;MAC3C;;MAEA;MACAF,MAAM,CAACC,CAAC,CAAC,GAAG,CAAED,MAAM,CAACC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAI,CAAC,IAAIC,SAAS;;MAElD;MACA,IAAI3I,EAAC,EAAE;QACLyI,MAAM,CAACC,CAAC,CAAC,IACN,CAACT,UAAU,CAACS,CAAC,GAAG,CAAC,CAAC,GAAGT,UAAU,CAACS,CAAC,CAAC,KAAK,CAAC,GAAI,CAAC,GAAGT,UAAU,CAACS,CAAC,GAAG,CAAC,CAAC;MACtE;MAEA,IAAID,MAAM,CAACC,CAAC,CAAC,GAAGN,IAAI,EAAE;QACpBF,UAAU,GAAGxC,cAAc,CAACC,OAAO,EAAE;UACnCG,MAAM,EAAE9F,EAAC;UACTgG,eAAe,EAAfA,eAAe;UACfE,gBAAgB,EAAhBA,gBAAgB;UAChBhF,QAAQ,EAARA,QAAQ;UACRG,cAAc,EAAdA;QACF,CAAC,CAAC;;QAEF;QACA;QACA,IAAI6G,UAAU,IAAIN,gBAAgB,EAAE;UAClC;UACAA,gBAAgB,GAAGM,UAAU;UAC7BL,YAAY,GAAG7B,eAAe;;UAE9B;UACA,IAAI6B,YAAY,IAAI3B,gBAAgB,EAAE;YACpC;UACF;;UAEA;UACAS,KAAK,GAAG1E,IAAI,CAACtE,GAAG,CAAC,CAAC,EAAE,CAAC,GAAGuI,gBAAgB,GAAG2B,YAAY,CAAC;QAC1D;MACF;IACF;;IAEA;IACA,IAAMhH,OAAK,GAAG6E,cAAc,CAACC,OAAO,EAAE;MACpCG,MAAM,EAAE9F,EAAC,GAAG,CAAC;MACbgG,eAAe,EAAEE,gBAAgB;MACjCA,gBAAgB,EAAhBA,gBAAgB;MAChBhF,QAAQ,EAARA,QAAQ;MACRG,cAAc,EAAdA;IACF,CAAC,CAAC;IAEF,IAAIR,OAAK,GAAG+G,gBAAgB,EAAE;MAC5B;IACF;IAEAK,UAAU,GAAGQ,MAAM;EACrB;EAEA,IAAMnM,MAAM,GAAG;IACbuM,OAAO,EAAEhB,YAAY,IAAI,CAAC;IAC1B;IACAhH,KAAK,EAAEoB,IAAI,CAACtE,GAAG,CAAC,KAAK,EAAEuK,UAAU;EACnC,CAAC;EAED,IAAIJ,cAAc,EAAE;IAClB,IAAMpB,OAAO,GAAGF,oBAAoB,CAACuB,SAAS,EAAE1H,kBAAkB,CAAC;IACnE,IAAI,CAACqG,OAAO,CAACzJ,MAAM,EAAE;MACnBX,MAAM,CAACuM,OAAO,GAAG,KAAK;IACxB,CAAC,MAAM,IAAI1I,cAAc,EAAE;MACzB7D,MAAM,CAACoK,OAAO,GAAGA,OAAO;IAC1B;EACF;EAEA,OAAOpK,MAAM;AACf;AAEA,SAASwM,qBAAqBA,CAACnD,OAAO,EAAE;EACtC,IAAIyC,IAAI,GAAG,CAAC,CAAC;EAEb,KAAK,IAAIpI,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG0F,OAAO,CAAC1I,MAAM,EAAE+C,CAAC,GAAGC,GAAG,EAAED,CAAC,IAAI,CAAC,EAAE;IACrD,IAAM+I,IAAI,GAAGpD,OAAO,CAACiD,MAAM,CAAC5I,CAAC,CAAC;IAC9BoI,IAAI,CAACW,IAAI,CAAC,GAAG,CAACX,IAAI,CAACW,IAAI,CAAC,IAAI,CAAC,IAAK,CAAC,IAAK9I,GAAG,GAAGD,CAAC,GAAG,CAAG;EACvD;EAEA,OAAOoI,IAAI;AACb;AAAC,IAEKY,WAAW;EACf,SAAAA,YACErD,OAAO,EAWP;IAAA,IAAAsD,MAAA;IAAA,IAAAC,KAAA,GAAAtH,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MADI,CAAC,CAAC;MAAAuH,cAAA,GAAAD,KAAA,CARJlI,QAAQ;MAARA,QAAQ,GAAAmI,cAAA,cAAG3H,MAAM,CAACR,QAAQ,GAAAmI,cAAA;MAAAC,eAAA,GAAAF,KAAA,CAC1BjI,SAAS;MAATA,SAAS,GAAAmI,eAAA,cAAG5H,MAAM,CAACP,SAAS,GAAAmI,eAAA;MAAAC,cAAA,GAAAH,KAAA,CAC5BhI,QAAQ;MAARA,QAAQ,GAAAmI,cAAA,cAAG7H,MAAM,CAACN,QAAQ,GAAAmI,cAAA;MAAAC,oBAAA,GAAAJ,KAAA,CAC1B/I,cAAc;MAAdA,cAAc,GAAAmJ,oBAAA,cAAG9H,MAAM,CAACrB,cAAc,GAAAmJ,oBAAA;MAAAC,oBAAA,GAAAL,KAAA,CACtC9I,cAAc;MAAdA,cAAc,GAAAmJ,oBAAA,cAAG/H,MAAM,CAACpB,cAAc,GAAAmJ,oBAAA;MAAAC,qBAAA,GAAAN,KAAA,CACtC7I,kBAAkB;MAAlBA,kBAAkB,GAAAmJ,qBAAA,cAAGhI,MAAM,CAACnB,kBAAkB,GAAAmJ,qBAAA;MAAAC,qBAAA,GAAAP,KAAA,CAC9C3I,eAAe;MAAfA,eAAe,GAAAkJ,qBAAA,cAAGjI,MAAM,CAACjB,eAAe,GAAAkJ,qBAAA;MAAAC,oBAAA,GAAAR,KAAA,CACxC7H,cAAc;MAAdA,cAAc,GAAAqI,oBAAA,cAAGlI,MAAM,CAACH,cAAc,GAAAqI,oBAAA;IAAAtL,eAAA,OAAA4K,WAAA;IAGxC,IAAI,CAACW,OAAO,GAAG;MACb3I,QAAQ,EAARA,QAAQ;MACRC,SAAS,EAATA,SAAS;MACTC,QAAQ,EAARA,QAAQ;MACRf,cAAc,EAAdA,cAAc;MACdC,cAAc,EAAdA,cAAc;MACdC,kBAAkB,EAAlBA,kBAAkB;MAClBE,eAAe,EAAfA,eAAe;MACfc,cAAc,EAAdA;IACF,CAAC;IAED,IAAI,CAACsE,OAAO,GAAGpF,eAAe,GAAGoF,OAAO,GAAGA,OAAO,CAACiE,WAAW,CAAC,CAAC;IAEhE,IAAI,CAACC,MAAM,GAAG,EAAE;IAEhB,IAAI,CAAC,IAAI,CAAClE,OAAO,CAAC1I,MAAM,EAAE;MACxB;IACF;IAEA,IAAM6M,QAAQ,GAAG,SAAXA,QAAQA,CAAInE,OAAO,EAAEoE,UAAU,EAAK;MACxCd,MAAI,CAACY,MAAM,CAACjL,IAAI,CAAC;QACf+G,OAAO,EAAPA,OAAO;QACPqE,QAAQ,EAAElB,qBAAqB,CAACnD,OAAO,CAAC;QACxCoE,UAAU,EAAVA;MACF,CAAC,CAAC;IACJ,CAAC;IAED,IAAM9J,GAAG,GAAG,IAAI,CAAC0F,OAAO,CAAC1I,MAAM;IAE/B,IAAIgD,GAAG,GAAG4G,QAAQ,EAAE;MAClB,IAAI7G,CAAC,GAAG,CAAC;MACT,IAAMiK,SAAS,GAAGhK,GAAG,GAAG4G,QAAQ;MAChC,IAAMD,GAAG,GAAG3G,GAAG,GAAGgK,SAAS;MAE3B,OAAOjK,CAAC,GAAG4G,GAAG,EAAE;QACdkD,QAAQ,CAAC,IAAI,CAACnE,OAAO,CAACuE,MAAM,CAAClK,CAAC,EAAE6G,QAAQ,CAAC,EAAE7G,CAAC,CAAC;QAC7CA,CAAC,IAAI6G,QAAQ;MACf;MAEA,IAAIoD,SAAS,EAAE;QACb,IAAMF,UAAU,GAAG9J,GAAG,GAAG4G,QAAQ;QACjCiD,QAAQ,CAAC,IAAI,CAACnE,OAAO,CAACuE,MAAM,CAACH,UAAU,CAAC,EAAEA,UAAU,CAAC;MACvD;IACF,CAAC,MAAM;MACLD,QAAQ,CAAC,IAAI,CAACnE,OAAO,EAAE,CAAC,CAAC;IAC3B;EACF;EAAC7G,YAAA,CAAAkK,WAAA;IAAAxL,GAAA;IAAAvB,KAAA,EAED,SAAAkO,SAASpD,IAAI,EAAE;MACb,IAAAqD,aAAA,GAA4C,IAAI,CAACT,OAAO;QAAhDpJ,eAAe,GAAA6J,aAAA,CAAf7J,eAAe;QAAEJ,cAAc,GAAAiK,aAAA,CAAdjK,cAAc;MAEvC,IAAI,CAACI,eAAe,EAAE;QACpBwG,IAAI,GAAGA,IAAI,CAAC6C,WAAW,CAAC,CAAC;MAC3B;;MAEA;MACA,IAAI,IAAI,CAACjE,OAAO,KAAKoB,IAAI,EAAE;QACzB,IAAIzK,OAAM,GAAG;UACXuM,OAAO,EAAE,IAAI;UACbhI,KAAK,EAAE;QACT,CAAC;QAED,IAAIV,cAAc,EAAE;UAClB7D,OAAM,CAACoK,OAAO,GAAG,CAAC,CAAC,CAAC,EAAEK,IAAI,CAAC9J,MAAM,GAAG,CAAC,CAAC,CAAC;QACzC;QAEA,OAAOX,OAAM;MACf;;MAEA;MACA,IAAA+N,cAAA,GAOI,IAAI,CAACV,OAAO;QANd3I,QAAQ,GAAAqJ,cAAA,CAARrJ,QAAQ;QACRE,QAAQ,GAAAmJ,cAAA,CAARnJ,QAAQ;QACRD,SAAS,GAAAoJ,cAAA,CAATpJ,SAAS;QACTb,cAAc,GAAAiK,cAAA,CAAdjK,cAAc;QACdC,kBAAkB,GAAAgK,cAAA,CAAlBhK,kBAAkB;QAClBgB,cAAc,GAAAgJ,cAAA,CAAdhJ,cAAc;MAGhB,IAAIiJ,UAAU,GAAG,EAAE;MACnB,IAAIC,UAAU,GAAG,CAAC;MAClB,IAAIC,UAAU,GAAG,KAAK;MAEtB,IAAI,CAACX,MAAM,CAACrL,OAAO,CAAC,UAAAiM,KAAA,EAAuC;QAAA,IAApC9E,OAAO,GAAA8E,KAAA,CAAP9E,OAAO;UAAEqE,QAAQ,GAAAS,KAAA,CAART,QAAQ;UAAED,UAAU,GAAAU,KAAA,CAAVV,UAAU;QAClD,IAAAW,OAAA,GAAoC5D,MAAM,CAACC,IAAI,EAAEpB,OAAO,EAAEqE,QAAQ,EAAE;YAClEhJ,QAAQ,EAAEA,QAAQ,GAAG+I,UAAU;YAC/B7I,QAAQ,EAARA,QAAQ;YACRD,SAAS,EAATA,SAAS;YACTb,cAAc,EAAdA,cAAc;YACdC,kBAAkB,EAAlBA,kBAAkB;YAClBF,cAAc,EAAdA,cAAc;YACdkB,cAAc,EAAdA;UACF,CAAC,CAAC;UARMwH,OAAO,GAAA6B,OAAA,CAAP7B,OAAO;UAAEhI,KAAK,GAAA6J,OAAA,CAAL7J,KAAK;UAAE6F,OAAO,GAAAgE,OAAA,CAAPhE,OAAO;QAU/B,IAAImC,OAAO,EAAE;UACX2B,UAAU,GAAG,IAAI;QACnB;QAEAD,UAAU,IAAI1J,KAAK;QAEnB,IAAIgI,OAAO,IAAInC,OAAO,EAAE;UACtB4D,UAAU,MAAA7M,MAAA,CAAAkN,kBAAA,CAAOL,UAAU,GAAAK,kBAAA,CAAKjE,OAAO,EAAC;QAC1C;MACF,CAAC,CAAC;MAEF,IAAIpK,MAAM,GAAG;QACXuM,OAAO,EAAE2B,UAAU;QACnB3J,KAAK,EAAE2J,UAAU,GAAGD,UAAU,GAAG,IAAI,CAACV,MAAM,CAAC5M,MAAM,GAAG;MACxD,CAAC;MAED,IAAIuN,UAAU,IAAIrK,cAAc,EAAE;QAChC7D,MAAM,CAACoK,OAAO,GAAG4D,UAAU;MAC7B;MAEA,OAAOhO,MAAM;IACf;EAAC;EAAA,OAAA0M,WAAA;AAAA;AAAA,IAGG4B,SAAS;EACb,SAAAA,UAAYjF,OAAO,EAAE;IAAAvH,eAAA,OAAAwM,SAAA;IACnB,IAAI,CAACjF,OAAO,GAAGA,OAAO;EACxB;EAAC7G,YAAA,CAAA8L,SAAA;IAAApN,GAAA;IAAAvB,KAAA,EAOD,SAAA6K,OAAA,CAAO,UAAU,CAAC;EAAC;IAAAtJ,GAAA;IAAAvB,KAAA,EANnB,SAAA4O,aAAoBlF,OAAO,EAAE;MAC3B,OAAOmF,QAAQ,CAACnF,OAAO,EAAE,IAAI,CAACoF,UAAU,CAAC;IAC3C;EAAC;IAAAvN,GAAA;IAAAvB,KAAA,EACD,SAAA+O,cAAqBrF,OAAO,EAAE;MAC5B,OAAOmF,QAAQ,CAACnF,OAAO,EAAE,IAAI,CAACsF,WAAW,CAAC;IAC5C;EAAC;EAAA,OAAAL,SAAA;AAAA;AAIH,SAASE,QAAQA,CAACnF,OAAO,EAAEuF,GAAG,EAAE;EAC9B,IAAMC,OAAO,GAAGxF,OAAO,CAACvD,KAAK,CAAC8I,GAAG,CAAC;EAClC,OAAOC,OAAO,GAAGA,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI;AACpC;;AAEA;AAAA,IAEMC,UAAU,0BAAAC,UAAA;EAAAC,SAAA,CAAAF,UAAA,EAAAC,UAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,UAAA;EACd,SAAAA,WAAYzF,OAAO,EAAE;IAAAvH,eAAA,OAAAgN,UAAA;IAAA,OAAAG,MAAA,CAAAnO,IAAA,OACbuI,OAAO;EACf;EAAC7G,YAAA,CAAAsM,UAAA;IAAA5N,GAAA;IAAAvB,KAAA,EAUD,SAAA6K,OAAOC,IAAI,EAAE;MACX,IAAM8B,OAAO,GAAG9B,IAAI,KAAK,IAAI,CAACpB,OAAO;MAErC,OAAO;QACLkD,OAAO,EAAPA,OAAO;QACPhI,KAAK,EAAEgI,OAAO,GAAG,CAAC,GAAG,CAAC;QACtBnC,OAAO,EAAE,CAAC,CAAC,EAAE,IAAI,CAACf,OAAO,CAAC1I,MAAM,GAAG,CAAC;MACtC,CAAC;IACH;EAAC;IAAAO,GAAA;IAAAuB,GAAA,EAjBD,SAAAA,IAAA,EAAkB;MAChB,OAAO,OAAO;IAChB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAwB;MACtB,OAAO,WAAW;IACpB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAyB;MACvB,OAAO,SAAS;IAClB;EAAC;EAAA,OAAAqM,UAAA;AAAA,EAZsBR,SAAS,GAwBlC;AAAA,IAEMa,iBAAiB,0BAAAC,WAAA;EAAAJ,SAAA,CAAAG,iBAAA,EAAAC,WAAA;EAAA,IAAAC,OAAA,GAAAH,YAAA,CAAAC,iBAAA;EACrB,SAAAA,kBAAY9F,OAAO,EAAE;IAAAvH,eAAA,OAAAqN,iBAAA;IAAA,OAAAE,OAAA,CAAAvO,IAAA,OACbuI,OAAO;EACf;EAAC7G,YAAA,CAAA2M,iBAAA;IAAAjO,GAAA;IAAAvB,KAAA,EAUD,SAAA6K,OAAOC,IAAI,EAAE;MACX,IAAMhH,KAAK,GAAGgH,IAAI,CAACiB,OAAO,CAAC,IAAI,CAACrC,OAAO,CAAC;MACxC,IAAMkD,OAAO,GAAG9I,KAAK,KAAK,CAAC,CAAC;MAE5B,OAAO;QACL8I,OAAO,EAAPA,OAAO;QACPhI,KAAK,EAAEgI,OAAO,GAAG,CAAC,GAAG,CAAC;QACtBnC,OAAO,EAAE,CAAC,CAAC,EAAEK,IAAI,CAAC9J,MAAM,GAAG,CAAC;MAC9B,CAAC;IACH;EAAC;IAAAO,GAAA;IAAAuB,GAAA,EAlBD,SAAAA,IAAA,EAAkB;MAChB,OAAO,eAAe;IACxB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAwB;MACtB,OAAO,WAAW;IACpB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAyB;MACvB,OAAO,SAAS;IAClB;EAAC;EAAA,OAAA0M,iBAAA;AAAA,EAZ6Bb,SAAS,GAyBzC;AAAA,IAEMgB,gBAAgB,0BAAAC,WAAA;EAAAP,SAAA,CAAAM,gBAAA,EAAAC,WAAA;EAAA,IAAAC,OAAA,GAAAN,YAAA,CAAAI,gBAAA;EACpB,SAAAA,iBAAYjG,OAAO,EAAE;IAAAvH,eAAA,OAAAwN,gBAAA;IAAA,OAAAE,OAAA,CAAA1O,IAAA,OACbuI,OAAO;EACf;EAAC7G,YAAA,CAAA8M,gBAAA;IAAApO,GAAA;IAAAvB,KAAA,EAUD,SAAA6K,OAAOC,IAAI,EAAE;MACX,IAAM8B,OAAO,GAAG9B,IAAI,CAACgF,UAAU,CAAC,IAAI,CAACpG,OAAO,CAAC;MAE7C,OAAO;QACLkD,OAAO,EAAPA,OAAO;QACPhI,KAAK,EAAEgI,OAAO,GAAG,CAAC,GAAG,CAAC;QACtBnC,OAAO,EAAE,CAAC,CAAC,EAAE,IAAI,CAACf,OAAO,CAAC1I,MAAM,GAAG,CAAC;MACtC,CAAC;IACH;EAAC;IAAAO,GAAA;IAAAuB,GAAA,EAjBD,SAAAA,IAAA,EAAkB;MAChB,OAAO,cAAc;IACvB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAwB;MACtB,OAAO,YAAY;IACrB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAyB;MACvB,OAAO,UAAU;IACnB;EAAC;EAAA,OAAA6M,gBAAA;AAAA,EAZ4BhB,SAAS,GAwBxC;AAAA,IAEMoB,uBAAuB,0BAAAC,WAAA;EAAAX,SAAA,CAAAU,uBAAA,EAAAC,WAAA;EAAA,IAAAC,OAAA,GAAAV,YAAA,CAAAQ,uBAAA;EAC3B,SAAAA,wBAAYrG,OAAO,EAAE;IAAAvH,eAAA,OAAA4N,uBAAA;IAAA,OAAAE,OAAA,CAAA9O,IAAA,OACbuI,OAAO;EACf;EAAC7G,YAAA,CAAAkN,uBAAA;IAAAxO,GAAA;IAAAvB,KAAA,EAUD,SAAA6K,OAAOC,IAAI,EAAE;MACX,IAAM8B,OAAO,GAAG,CAAC9B,IAAI,CAACgF,UAAU,CAAC,IAAI,CAACpG,OAAO,CAAC;MAE9C,OAAO;QACLkD,OAAO,EAAPA,OAAO;QACPhI,KAAK,EAAEgI,OAAO,GAAG,CAAC,GAAG,CAAC;QACtBnC,OAAO,EAAE,CAAC,CAAC,EAAEK,IAAI,CAAC9J,MAAM,GAAG,CAAC;MAC9B,CAAC;IACH;EAAC;IAAAO,GAAA;IAAAuB,GAAA,EAjBD,SAAAA,IAAA,EAAkB;MAChB,OAAO,sBAAsB;IAC/B;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAwB;MACtB,OAAO,aAAa;IACtB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAyB;MACvB,OAAO,WAAW;IACpB;EAAC;EAAA,OAAAiN,uBAAA;AAAA,EAZmCpB,SAAS,GAwB/C;AAAA,IAEMuB,gBAAgB,0BAAAC,WAAA;EAAAd,SAAA,CAAAa,gBAAA,EAAAC,WAAA;EAAA,IAAAC,OAAA,GAAAb,YAAA,CAAAW,gBAAA;EACpB,SAAAA,iBAAYxG,OAAO,EAAE;IAAAvH,eAAA,OAAA+N,gBAAA;IAAA,OAAAE,OAAA,CAAAjP,IAAA,OACbuI,OAAO;EACf;EAAC7G,YAAA,CAAAqN,gBAAA;IAAA3O,GAAA;IAAAvB,KAAA,EAUD,SAAA6K,OAAOC,IAAI,EAAE;MACX,IAAM8B,OAAO,GAAG9B,IAAI,CAACuF,QAAQ,CAAC,IAAI,CAAC3G,OAAO,CAAC;MAE3C,OAAO;QACLkD,OAAO,EAAPA,OAAO;QACPhI,KAAK,EAAEgI,OAAO,GAAG,CAAC,GAAG,CAAC;QACtBnC,OAAO,EAAE,CAACK,IAAI,CAAC9J,MAAM,GAAG,IAAI,CAAC0I,OAAO,CAAC1I,MAAM,EAAE8J,IAAI,CAAC9J,MAAM,GAAG,CAAC;MAC9D,CAAC;IACH;EAAC;IAAAO,GAAA;IAAAuB,GAAA,EAjBD,SAAAA,IAAA,EAAkB;MAChB,OAAO,cAAc;IACvB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAwB;MACtB,OAAO,YAAY;IACrB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAyB;MACvB,OAAO,UAAU;IACnB;EAAC;EAAA,OAAAoN,gBAAA;AAAA,EAZ4BvB,SAAS,GAwBxC;AAAA,IAEM2B,uBAAuB,0BAAAC,WAAA;EAAAlB,SAAA,CAAAiB,uBAAA,EAAAC,WAAA;EAAA,IAAAC,OAAA,GAAAjB,YAAA,CAAAe,uBAAA;EAC3B,SAAAA,wBAAY5G,OAAO,EAAE;IAAAvH,eAAA,OAAAmO,uBAAA;IAAA,OAAAE,OAAA,CAAArP,IAAA,OACbuI,OAAO;EACf;EAAC7G,YAAA,CAAAyN,uBAAA;IAAA/O,GAAA;IAAAvB,KAAA,EAUD,SAAA6K,OAAOC,IAAI,EAAE;MACX,IAAM8B,OAAO,GAAG,CAAC9B,IAAI,CAACuF,QAAQ,CAAC,IAAI,CAAC3G,OAAO,CAAC;MAC5C,OAAO;QACLkD,OAAO,EAAPA,OAAO;QACPhI,KAAK,EAAEgI,OAAO,GAAG,CAAC,GAAG,CAAC;QACtBnC,OAAO,EAAE,CAAC,CAAC,EAAEK,IAAI,CAAC9J,MAAM,GAAG,CAAC;MAC9B,CAAC;IACH;EAAC;IAAAO,GAAA;IAAAuB,GAAA,EAhBD,SAAAA,IAAA,EAAkB;MAChB,OAAO,sBAAsB;IAC/B;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAwB;MACtB,OAAO,aAAa;IACtB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAyB;MACvB,OAAO,WAAW;IACpB;EAAC;EAAA,OAAAwN,uBAAA;AAAA,EAZmC3B,SAAS;AAAA,IAuBzC8B,UAAU,0BAAAC,WAAA;EAAArB,SAAA,CAAAoB,UAAA,EAAAC,WAAA;EAAA,IAAAC,OAAA,GAAApB,YAAA,CAAAkB,UAAA;EACd,SAAAA,WACE/G,OAAO,EAWP;IAAA,IAAAkH,MAAA;IAAA,IAAAC,KAAA,GAAAlL,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MADI,CAAC,CAAC;MAAAmL,cAAA,GAAAD,KAAA,CARJ9L,QAAQ;MAARA,QAAQ,GAAA+L,cAAA,cAAGvL,MAAM,CAACR,QAAQ,GAAA+L,cAAA;MAAAC,eAAA,GAAAF,KAAA,CAC1B7L,SAAS;MAATA,SAAS,GAAA+L,eAAA,cAAGxL,MAAM,CAACP,SAAS,GAAA+L,eAAA;MAAAC,cAAA,GAAAH,KAAA,CAC5B5L,QAAQ;MAARA,QAAQ,GAAA+L,cAAA,cAAGzL,MAAM,CAACN,QAAQ,GAAA+L,cAAA;MAAAC,oBAAA,GAAAJ,KAAA,CAC1B3M,cAAc;MAAdA,cAAc,GAAA+M,oBAAA,cAAG1L,MAAM,CAACrB,cAAc,GAAA+M,oBAAA;MAAAC,oBAAA,GAAAL,KAAA,CACtC1M,cAAc;MAAdA,cAAc,GAAA+M,oBAAA,cAAG3L,MAAM,CAACpB,cAAc,GAAA+M,oBAAA;MAAAC,qBAAA,GAAAN,KAAA,CACtCzM,kBAAkB;MAAlBA,kBAAkB,GAAA+M,qBAAA,cAAG5L,MAAM,CAACnB,kBAAkB,GAAA+M,qBAAA;MAAAC,qBAAA,GAAAP,KAAA,CAC9CvM,eAAe;MAAfA,eAAe,GAAA8M,qBAAA,cAAG7L,MAAM,CAACjB,eAAe,GAAA8M,qBAAA;MAAAC,oBAAA,GAAAR,KAAA,CACxCzL,cAAc;MAAdA,cAAc,GAAAiM,oBAAA,cAAG9L,MAAM,CAACH,cAAc,GAAAiM,oBAAA;IAAAlP,eAAA,OAAAsO,UAAA;IAGxCG,MAAA,GAAAD,OAAA,CAAAxP,IAAA,OAAMuI,OAAO;IACbkH,MAAA,CAAKU,YAAY,GAAG,IAAIvE,WAAW,CAACrD,OAAO,EAAE;MAC3C3E,QAAQ,EAARA,QAAQ;MACRC,SAAS,EAATA,SAAS;MACTC,QAAQ,EAARA,QAAQ;MACRf,cAAc,EAAdA,cAAc;MACdC,cAAc,EAAdA,cAAc;MACdC,kBAAkB,EAAlBA,kBAAkB;MAClBE,eAAe,EAAfA,eAAe;MACfc,cAAc,EAAdA;IACF,CAAC,CAAC;IAAC,OAAAwL,MAAA;EACL;EAAC/N,YAAA,CAAA4N,UAAA;IAAAlP,GAAA;IAAAvB,KAAA,EAUD,SAAA6K,OAAOC,IAAI,EAAE;MACX,OAAO,IAAI,CAACwG,YAAY,CAACpD,QAAQ,CAACpD,IAAI,CAAC;IACzC;EAAC;IAAAvJ,GAAA;IAAAuB,GAAA,EAXD,SAAAA,IAAA,EAAkB;MAChB,OAAO,OAAO;IAChB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAwB;MACtB,OAAO,UAAU;IACnB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAyB;MACvB,OAAO,QAAQ;IACjB;EAAC;EAAA,OAAA2N,UAAA;AAAA,EAlCsB9B,SAAS,GAwClC;AAAA,IAEM4C,YAAY,0BAAAC,WAAA;EAAAnC,SAAA,CAAAkC,YAAA,EAAAC,WAAA;EAAA,IAAAC,OAAA,GAAAlC,YAAA,CAAAgC,YAAA;EAChB,SAAAA,aAAY7H,OAAO,EAAE;IAAAvH,eAAA,OAAAoP,YAAA;IAAA,OAAAE,OAAA,CAAAtQ,IAAA,OACbuI,OAAO;EACf;EAAC7G,YAAA,CAAA0O,YAAA;IAAAhQ,GAAA;IAAAvB,KAAA,EAUD,SAAA6K,OAAOC,IAAI,EAAE;MACX,IAAI/F,QAAQ,GAAG,CAAC;MAChB,IAAIjB,KAAK;MAET,IAAM2G,OAAO,GAAG,EAAE;MAClB,IAAMe,UAAU,GAAG,IAAI,CAAC9B,OAAO,CAAC1I,MAAM;;MAEtC;MACA,OAAO,CAAC8C,KAAK,GAAGgH,IAAI,CAACiB,OAAO,CAAC,IAAI,CAACrC,OAAO,EAAE3E,QAAQ,CAAC,IAAI,CAAC,CAAC,EAAE;QAC1DA,QAAQ,GAAGjB,KAAK,GAAG0H,UAAU;QAC7Bf,OAAO,CAAC9H,IAAI,CAAC,CAACmB,KAAK,EAAEiB,QAAQ,GAAG,CAAC,CAAC,CAAC;MACrC;MAEA,IAAM6H,OAAO,GAAG,CAAC,CAACnC,OAAO,CAACzJ,MAAM;MAEhC,OAAO;QACL4L,OAAO,EAAPA,OAAO;QACPhI,KAAK,EAAEgI,OAAO,GAAG,CAAC,GAAG,CAAC;QACtBnC,OAAO,EAAPA;MACF,CAAC;IACH;EAAC;IAAAlJ,GAAA;IAAAuB,GAAA,EA7BD,SAAAA,IAAA,EAAkB;MAChB,OAAO,SAAS;IAClB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAwB;MACtB,OAAO,WAAW;IACpB;EAAC;IAAAvB,GAAA;IAAAuB,GAAA,EACD,SAAAA,IAAA,EAAyB;MACvB,OAAO,SAAS;IAClB;EAAC;EAAA,OAAAyO,YAAA;AAAA,EAZwB5C,SAAS,GAoCpC;AACA,IAAM+C,SAAS,GAAG,CAChBvC,UAAU,EACVoC,YAAY,EACZ5B,gBAAgB,EAChBI,uBAAuB,EACvBO,uBAAuB,EACvBJ,gBAAgB,EAChBV,iBAAiB,EACjBiB,UAAU,CACX;AAED,IAAMkB,YAAY,GAAGD,SAAS,CAAC1Q,MAAM;;AAErC;AACA,IAAM4Q,QAAQ,GAAG,oCAAoC;AACrD,IAAMC,QAAQ,GAAG,GAAG;;AAEpB;AACA;AACA;AACA,SAASC,UAAUA,CAACpI,OAAO,EAAgB;EAAA,IAAdgE,OAAO,GAAA/H,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAG,CAAC,CAAC;EACvC,OAAO+D,OAAO,CAACjG,KAAK,CAACoO,QAAQ,CAAC,CAAC1I,GAAG,CAAC,UAAClB,IAAI,EAAK;IAC3C,IAAI8J,KAAK,GAAG9J,IAAI,CACblH,IAAI,CAAC,CAAC,CACN0C,KAAK,CAACmO,QAAQ,CAAC,CACfI,MAAM,CAAC,UAAC/J,IAAI;MAAA,OAAKA,IAAI,IAAI,CAAC,CAACA,IAAI,CAAClH,IAAI,CAAC,CAAC;IAAA,EAAC;IAE1C,IAAIkR,OAAO,GAAG,EAAE;IAChB,KAAK,IAAIlO,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG+N,KAAK,CAAC/Q,MAAM,EAAE+C,CAAC,GAAGC,GAAG,EAAED,CAAC,IAAI,CAAC,EAAE;MACnD,IAAMmO,SAAS,GAAGH,KAAK,CAAChO,CAAC,CAAC;;MAE1B;MACA,IAAIoO,KAAK,GAAG,KAAK;MACjB,IAAItN,GAAG,GAAG,CAAC,CAAC;MACZ,OAAO,CAACsN,KAAK,IAAI,EAAEtN,GAAG,GAAG8M,YAAY,EAAE;QACrC,IAAMS,QAAQ,GAAGV,SAAS,CAAC7M,GAAG,CAAC;QAC/B,IAAIwN,KAAK,GAAGD,QAAQ,CAACxD,YAAY,CAACsD,SAAS,CAAC;QAC5C,IAAIG,KAAK,EAAE;UACTJ,OAAO,CAACtP,IAAI,CAAC,IAAIyP,QAAQ,CAACC,KAAK,EAAE3E,OAAO,CAAC,CAAC;UAC1CyE,KAAK,GAAG,IAAI;QACd;MACF;MAEA,IAAIA,KAAK,EAAE;QACT;MACF;;MAEA;MACAtN,GAAG,GAAG,CAAC,CAAC;MACR,OAAO,EAAEA,GAAG,GAAG8M,YAAY,EAAE;QAC3B,IAAMS,SAAQ,GAAGV,SAAS,CAAC7M,GAAG,CAAC;QAC/B,IAAIwN,MAAK,GAAGD,SAAQ,CAACrD,aAAa,CAACmD,SAAS,CAAC;QAC7C,IAAIG,MAAK,EAAE;UACTJ,OAAO,CAACtP,IAAI,CAAC,IAAIyP,SAAQ,CAACC,MAAK,EAAE3E,OAAO,CAAC,CAAC;UAC1C;QACF;MACF;IACF;IAEA,OAAOuE,OAAO;EAChB,CAAC,CAAC;AACJ;;AAEA;AACA;AACA,IAAMK,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC9B,UAAU,CAAC+B,IAAI,EAAEjB,YAAY,CAACiB,IAAI,CAAC,CAAC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3BA,IA4BMC,cAAc;EAClB,SAAAA,eACE/I,OAAO,EAWP;IAAA,IAAAgJ,KAAA,GAAA/M,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MADI,CAAC,CAAC;MAAAgN,qBAAA,GAAAD,KAAA,CARJpO,eAAe;MAAfA,eAAe,GAAAqO,qBAAA,cAAGpN,MAAM,CAACjB,eAAe,GAAAqO,qBAAA;MAAAC,oBAAA,GAAAF,KAAA,CACxCxO,cAAc;MAAdA,cAAc,GAAA0O,oBAAA,cAAGrN,MAAM,CAACrB,cAAc,GAAA0O,oBAAA;MAAAC,qBAAA,GAAAH,KAAA,CACtCtO,kBAAkB;MAAlBA,kBAAkB,GAAAyO,qBAAA,cAAGtN,MAAM,CAACnB,kBAAkB,GAAAyO,qBAAA;MAAAC,oBAAA,GAAAJ,KAAA,CAC9CtN,cAAc;MAAdA,cAAc,GAAA0N,oBAAA,cAAGvN,MAAM,CAACH,cAAc,GAAA0N,oBAAA;MAAAC,oBAAA,GAAAL,KAAA,CACtCvO,cAAc;MAAdA,cAAc,GAAA4O,oBAAA,cAAGxN,MAAM,CAACpB,cAAc,GAAA4O,oBAAA;MAAAC,cAAA,GAAAN,KAAA,CACtC3N,QAAQ;MAARA,QAAQ,GAAAiO,cAAA,cAAGzN,MAAM,CAACR,QAAQ,GAAAiO,cAAA;MAAAC,eAAA,GAAAP,KAAA,CAC1B1N,SAAS;MAATA,SAAS,GAAAiO,eAAA,cAAG1N,MAAM,CAACP,SAAS,GAAAiO,eAAA;MAAAC,cAAA,GAAAR,KAAA,CAC5BzN,QAAQ;MAARA,QAAQ,GAAAiO,cAAA,cAAG3N,MAAM,CAACN,QAAQ,GAAAiO,cAAA;IAAA/Q,eAAA,OAAAsQ,cAAA;IAG5B,IAAI,CAACV,KAAK,GAAG,IAAI;IACjB,IAAI,CAACrE,OAAO,GAAG;MACbpJ,eAAe,EAAfA,eAAe;MACfJ,cAAc,EAAdA,cAAc;MACdE,kBAAkB,EAAlBA,kBAAkB;MAClBD,cAAc,EAAdA,cAAc;MACdiB,cAAc,EAAdA,cAAc;MACdL,QAAQ,EAARA,QAAQ;MACRC,SAAS,EAATA,SAAS;MACTC,QAAQ,EAARA;IACF,CAAC;IAED,IAAI,CAACyE,OAAO,GAAGpF,eAAe,GAAGoF,OAAO,GAAGA,OAAO,CAACiE,WAAW,CAAC,CAAC;IAChE,IAAI,CAACoE,KAAK,GAAGD,UAAU,CAAC,IAAI,CAACpI,OAAO,EAAE,IAAI,CAACgE,OAAO,CAAC;EACrD;EAAC7K,YAAA,CAAA4P,cAAA;IAAAlR,GAAA;IAAAvB,KAAA,EAMD,SAAAkO,SAASpD,IAAI,EAAE;MACb,IAAMiH,KAAK,GAAG,IAAI,CAACA,KAAK;MAExB,IAAI,CAACA,KAAK,EAAE;QACV,OAAO;UACLnF,OAAO,EAAE,KAAK;UACdhI,KAAK,EAAE;QACT,CAAC;MACH;MAEA,IAAAuO,cAAA,GAA4C,IAAI,CAACzF,OAAO;QAAhDxJ,cAAc,GAAAiP,cAAA,CAAdjP,cAAc;QAAEI,eAAe,GAAA6O,cAAA,CAAf7O,eAAe;MAEvCwG,IAAI,GAAGxG,eAAe,GAAGwG,IAAI,GAAGA,IAAI,CAAC6C,WAAW,CAAC,CAAC;MAElD,IAAIyF,UAAU,GAAG,CAAC;MAClB,IAAI/E,UAAU,GAAG,EAAE;MACnB,IAAIC,UAAU,GAAG,CAAC;;MAElB;MACA,KAAK,IAAIvK,CAAC,GAAG,CAAC,EAAEsP,IAAI,GAAGtB,KAAK,CAAC/Q,MAAM,EAAE+C,CAAC,GAAGsP,IAAI,EAAEtP,CAAC,IAAI,CAAC,EAAE;QACrD,IAAM2N,UAAS,GAAGK,KAAK,CAAChO,CAAC,CAAC;;QAE1B;QACAsK,UAAU,CAACrN,MAAM,GAAG,CAAC;QACrBoS,UAAU,GAAG,CAAC;;QAEd;QACA,KAAK,IAAI3G,CAAC,GAAG,CAAC,EAAE6G,IAAI,GAAG5B,UAAS,CAAC1Q,MAAM,EAAEyL,CAAC,GAAG6G,IAAI,EAAE7G,CAAC,IAAI,CAAC,EAAE;UACzD,IAAM2F,QAAQ,GAAGV,UAAS,CAACjF,CAAC,CAAC;UAC7B,IAAA8G,gBAAA,GAAoCnB,QAAQ,CAACvH,MAAM,CAACC,IAAI,CAAC;YAAjD8B,OAAO,GAAA2G,gBAAA,CAAP3G,OAAO;YAAEnC,OAAO,GAAA8I,gBAAA,CAAP9I,OAAO;YAAE7F,KAAK,GAAA2O,gBAAA,CAAL3O,KAAK;UAE/B,IAAIgI,OAAO,EAAE;YACXwG,UAAU,IAAI,CAAC;YACf9E,UAAU,IAAI1J,KAAK;YACnB,IAAIV,cAAc,EAAE;cAClB,IAAMsO,IAAI,GAAGJ,QAAQ,CAACoB,WAAW,CAAChB,IAAI;cACtC,IAAIF,aAAa,CAAClM,GAAG,CAACoM,IAAI,CAAC,EAAE;gBAC3BnE,UAAU,MAAA7M,MAAA,CAAAkN,kBAAA,CAAOL,UAAU,GAAAK,kBAAA,CAAKjE,OAAO,EAAC;cAC1C,CAAC,MAAM;gBACL4D,UAAU,CAAC1L,IAAI,CAAC8H,OAAO,CAAC;cAC1B;YACF;UACF,CAAC,MAAM;YACL6D,UAAU,GAAG,CAAC;YACd8E,UAAU,GAAG,CAAC;YACd/E,UAAU,CAACrN,MAAM,GAAG,CAAC;YACrB;UACF;QACF;;QAEA;QACA,IAAIoS,UAAU,EAAE;UACd,IAAI/S,MAAM,GAAG;YACXuM,OAAO,EAAE,IAAI;YACbhI,KAAK,EAAE0J,UAAU,GAAG8E;UACtB,CAAC;UAED,IAAIlP,cAAc,EAAE;YAClB7D,MAAM,CAACoK,OAAO,GAAG4D,UAAU;UAC7B;UAEA,OAAOhO,MAAM;QACf;MACF;;MAEA;MACA,OAAO;QACLuM,OAAO,EAAE,KAAK;QACdhI,KAAK,EAAE;MACT,CAAC;IACH;EAAC;IAAArD,GAAA;IAAAvB,KAAA,EA1ED,SAAAyT,UAAiBC,CAAC,EAAEhG,OAAO,EAAE;MAC3B,OAAOA,OAAO,CAACvI,iBAAiB;IAClC;EAAC;EAAA,OAAAsN,cAAA;AAAA;AA2EH,IAAMkB,mBAAmB,GAAG,EAAE;AAE9B,SAASC,QAAQA,CAAA,EAAU;EACzBD,mBAAmB,CAAChR,IAAI,CAAAkR,KAAA,CAAxBF,mBAAmB,EAAAhO,SAAa,CAAC;AACnC;AAEA,SAASmO,cAAcA,CAACpK,OAAO,EAAEgE,OAAO,EAAE;EACxC,KAAK,IAAI3J,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG2P,mBAAmB,CAAC3S,MAAM,EAAE+C,CAAC,GAAGC,GAAG,EAAED,CAAC,IAAI,CAAC,EAAE;IACjE,IAAIgQ,aAAa,GAAGJ,mBAAmB,CAAC5P,CAAC,CAAC;IAC1C,IAAIgQ,aAAa,CAACN,SAAS,CAAC/J,OAAO,EAAEgE,OAAO,CAAC,EAAE;MAC7C,OAAO,IAAIqG,aAAa,CAACrK,OAAO,EAAEgE,OAAO,CAAC;IAC5C;EACF;EAEA,OAAO,IAAIX,WAAW,CAACrD,OAAO,EAAEgE,OAAO,CAAC;AAC1C;AAEA,IAAMsG,eAAe,GAAG;EACtBC,GAAG,EAAE,MAAM;EACXC,EAAE,EAAE;AACN,CAAC;AAED,IAAMC,OAAO,GAAG;EACdC,IAAI,EAAE,OAAO;EACbC,OAAO,EAAE;AACX,CAAC;AAED,IAAMC,YAAY,GAAG,SAAfA,YAAYA,CAAIvC,KAAK;EAAA,OACzB,CAAC,EAAEA,KAAK,CAACiC,eAAe,CAACC,GAAG,CAAC,IAAIlC,KAAK,CAACiC,eAAe,CAACE,EAAE,CAAC,CAAC;AAAA;AAE7D,IAAMK,MAAM,GAAG,SAATA,MAAMA,CAAIxC,KAAK;EAAA,OAAK,CAAC,CAACA,KAAK,CAACoC,OAAO,CAACC,IAAI,CAAC;AAAA;AAE/C,IAAMI,MAAM,GAAG,SAATA,MAAMA,CAAIzC,KAAK;EAAA,OACnB,CAAChS,OAAO,CAACgS,KAAK,CAAC,IAAIpR,QAAQ,CAACoR,KAAK,CAAC,IAAI,CAACuC,YAAY,CAACvC,KAAK,CAAC;AAAA;AAE5D,IAAM0C,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAI1C,KAAK;EAAA,OAAA2C,eAAA,KAC7BV,eAAe,CAACC,GAAG,EAAGhT,MAAM,CAACgB,IAAI,CAAC8P,KAAK,CAAC,CAAC5I,GAAG,CAAC,UAAC5H,GAAG;IAAA,OAAAmT,eAAA,KAC/CnT,GAAG,EAAGwQ,KAAK,CAACxQ,GAAG,CAAC;EAAA,CACjB,CAAC;AAAA,CACH;;AAEF;AACA;AACA,SAASoT,KAAKA,CAAC5C,KAAK,EAAErE,OAAO,EAAwB;EAAA,IAAAkH,MAAA,GAAAjP,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAJ,CAAC,CAAC;IAAAkP,WAAA,GAAAD,MAAA,CAAlBE,IAAI;IAAJA,IAAI,GAAAD,WAAA,cAAG,IAAI,GAAAA,WAAA;EAC1C,IAAME,IAAI,GAAG,SAAPA,IAAIA,CAAIhD,KAAK,EAAK;IACtB,IAAI9P,IAAI,GAAGhB,MAAM,CAACgB,IAAI,CAAC8P,KAAK,CAAC;IAE7B,IAAMiD,WAAW,GAAGT,MAAM,CAACxC,KAAK,CAAC;IAEjC,IAAI,CAACiD,WAAW,IAAI/S,IAAI,CAACjB,MAAM,GAAG,CAAC,IAAI,CAACsT,YAAY,CAACvC,KAAK,CAAC,EAAE;MAC3D,OAAOgD,IAAI,CAACN,iBAAiB,CAAC1C,KAAK,CAAC,CAAC;IACvC;IAEA,IAAIyC,MAAM,CAACzC,KAAK,CAAC,EAAE;MACjB,IAAMxQ,GAAG,GAAGyT,WAAW,GAAGjD,KAAK,CAACoC,OAAO,CAACC,IAAI,CAAC,GAAGnS,IAAI,CAAC,CAAC,CAAC;MAEvD,IAAMyH,OAAO,GAAGsL,WAAW,GAAGjD,KAAK,CAACoC,OAAO,CAACE,OAAO,CAAC,GAAGtC,KAAK,CAACxQ,GAAG,CAAC;MAEjE,IAAI,CAAChB,QAAQ,CAACmJ,OAAO,CAAC,EAAE;QACtB,MAAM,IAAIlG,KAAK,CAAClC,oCAAoC,CAACC,GAAG,CAAC,CAAC;MAC5D;MAEA,IAAMiB,GAAG,GAAG;QACVO,KAAK,EAAEQ,WAAW,CAAChC,GAAG,CAAC;QACvBmI,OAAO,EAAPA;MACF,CAAC;MAED,IAAIoL,IAAI,EAAE;QACRtS,GAAG,CAAC4P,QAAQ,GAAG0B,cAAc,CAACpK,OAAO,EAAEgE,OAAO,CAAC;MACjD;MAEA,OAAOlL,GAAG;IACZ;IAEA,IAAIyS,IAAI,GAAG;MACTC,QAAQ,EAAE,EAAE;MACZC,QAAQ,EAAElT,IAAI,CAAC,CAAC;IAClB,CAAC;IAEDA,IAAI,CAACM,OAAO,CAAC,UAAChB,GAAG,EAAK;MACpB,IAAMvB,KAAK,GAAG+R,KAAK,CAACxQ,GAAG,CAAC;MAExB,IAAIxB,OAAO,CAACC,KAAK,CAAC,EAAE;QAClBA,KAAK,CAACuC,OAAO,CAAC,UAAC0F,IAAI,EAAK;UACtBgN,IAAI,CAACC,QAAQ,CAACvS,IAAI,CAACoS,IAAI,CAAC9M,IAAI,CAAC,CAAC;QAChC,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IAEF,OAAOgN,IAAI;EACb,CAAC;EAED,IAAI,CAACX,YAAY,CAACvC,KAAK,CAAC,EAAE;IACxBA,KAAK,GAAG0C,iBAAiB,CAAC1C,KAAK,CAAC;EAClC;EAEA,OAAOgD,IAAI,CAAChD,KAAK,CAAC;AACpB;;AAEA;AACA,SAASqD,YAAYA,CACnBnD,OAAO,EAAAoD,MAAA,EAEP;EAAA,IAAAC,qBAAA,GAAAD,MAAA,CADEhQ,eAAe;IAAfA,eAAe,GAAAiQ,qBAAA,cAAG/P,MAAM,CAACF,eAAe,GAAAiQ,qBAAA;EAE1CrD,OAAO,CAAC1P,OAAO,CAAC,UAAClC,MAAM,EAAK;IAC1B,IAAIiO,UAAU,GAAG,CAAC;IAElBjO,MAAM,CAAC6O,OAAO,CAAC3M,OAAO,CAAC,UAAAgT,MAAA,EAA0B;MAAA,IAAvBhU,GAAG,GAAAgU,MAAA,CAAHhU,GAAG;QAAEmE,IAAI,GAAA6P,MAAA,CAAJ7P,IAAI;QAAEd,KAAK,GAAA2Q,MAAA,CAAL3Q,KAAK;MACxC,IAAMlC,MAAM,GAAGnB,GAAG,GAAGA,GAAG,CAACmB,MAAM,GAAG,IAAI;MAEtC4L,UAAU,IAAItI,IAAI,CAACC,GAAG,CACpBrB,KAAK,KAAK,CAAC,IAAIlC,MAAM,GAAG8S,MAAM,CAACC,OAAO,GAAG7Q,KAAK,EAC9C,CAAClC,MAAM,IAAI,CAAC,KAAK2C,eAAe,GAAG,CAAC,GAAGK,IAAI,CAC7C,CAAC;IACH,CAAC,CAAC;IAEFrF,MAAM,CAACuE,KAAK,GAAG0J,UAAU;EAC3B,CAAC,CAAC;AACJ;AAEA,SAASoH,gBAAgBA,CAACrV,MAAM,EAAEgJ,IAAI,EAAE;EACtC,IAAM6F,OAAO,GAAG7O,MAAM,CAAC6O,OAAO;EAC9B7F,IAAI,CAAC6F,OAAO,GAAG,EAAE;EAEjB,IAAI,CAACtO,SAAS,CAACsO,OAAO,CAAC,EAAE;IACvB;EACF;EAEAA,OAAO,CAAC3M,OAAO,CAAC,UAAC4D,KAAK,EAAK;IACzB,IAAI,CAACvF,SAAS,CAACuF,KAAK,CAACsE,OAAO,CAAC,IAAI,CAACtE,KAAK,CAACsE,OAAO,CAACzJ,MAAM,EAAE;MACtD;IACF;IAEA,IAAQyJ,OAAO,GAAYtE,KAAK,CAAxBsE,OAAO;MAAEzK,KAAK,GAAKmG,KAAK,CAAfnG,KAAK;IAEtB,IAAIwC,GAAG,GAAG;MACRiI,OAAO,EAAPA,OAAO;MACPzK,KAAK,EAALA;IACF,CAAC;IAED,IAAImG,KAAK,CAAC5E,GAAG,EAAE;MACbiB,GAAG,CAACjB,GAAG,GAAG4E,KAAK,CAAC5E,GAAG,CAAC6B,GAAG;IACzB;IAEA,IAAI+C,KAAK,CAACtB,GAAG,GAAG,CAAC,CAAC,EAAE;MAClBrC,GAAG,CAACmT,QAAQ,GAAGxP,KAAK,CAACtB,GAAG;IAC1B;IAEAwE,IAAI,CAAC6F,OAAO,CAACvM,IAAI,CAACH,GAAG,CAAC;EACxB,CAAC,CAAC;AACJ;AAEA,SAASoT,cAAcA,CAACvV,MAAM,EAAEgJ,IAAI,EAAE;EACpCA,IAAI,CAACzE,KAAK,GAAGvE,MAAM,CAACuE,KAAK;AAC3B;AAEA,SAASiR,MAAMA,CACb5D,OAAO,EACPhL,IAAI,EAKJ;EAAA,IAAA6O,MAAA,GAAAnQ,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MADI,CAAC,CAAC;IAAAoQ,qBAAA,GAAAD,MAAA,CAFJ5R,cAAc;IAAdA,cAAc,GAAA6R,qBAAA,cAAGxQ,MAAM,CAACrB,cAAc,GAAA6R,qBAAA;IAAAC,mBAAA,GAAAF,MAAA,CACtCvR,YAAY;IAAZA,YAAY,GAAAyR,mBAAA,cAAGzQ,MAAM,CAAChB,YAAY,GAAAyR,mBAAA;EAGpC,IAAMC,YAAY,GAAG,EAAE;EAEvB,IAAI/R,cAAc,EAAE+R,YAAY,CAACtT,IAAI,CAAC+S,gBAAgB,CAAC;EACvD,IAAInR,YAAY,EAAE0R,YAAY,CAACtT,IAAI,CAACiT,cAAc,CAAC;EAEnD,OAAO3D,OAAO,CAAC9I,GAAG,CAAC,UAAC9I,MAAM,EAAK;IAC7B,IAAQwE,GAAG,GAAKxE,MAAM,CAAdwE,GAAG;IAEX,IAAMwE,IAAI,GAAG;MACXpB,IAAI,EAAEhB,IAAI,CAACpC,GAAG,CAAC;MACf8Q,QAAQ,EAAE9Q;IACZ,CAAC;IAED,IAAIoR,YAAY,CAACjV,MAAM,EAAE;MACvBiV,YAAY,CAAC1T,OAAO,CAAC,UAAC2T,WAAW,EAAK;QACpCA,WAAW,CAAC7V,MAAM,EAAEgJ,IAAI,CAAC;MAC3B,CAAC,CAAC;IACJ;IAEA,OAAOA,IAAI;EACb,CAAC,CAAC;AACJ;AAAC,IAEK8M,IAAI;EACR,SAAAA,KAAYlP,IAAI,EAAuB;IAAA,IAArByG,OAAO,GAAA/H,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAG,CAAC,CAAC;IAAA,IAAE7B,KAAK,GAAA6B,SAAA,CAAA3E,MAAA,OAAA2E,SAAA,MAAA9E,SAAA;IAAAsB,eAAA,OAAAgU,IAAA;IACnC,IAAI,CAACzI,OAAO,GAAAlI,aAAA,CAAAA,aAAA,KAAQD,MAAM,GAAKmI,OAAO,CAAE;IAExC,IACE,IAAI,CAACA,OAAO,CAACvI,iBAAiB,IAC9B,CAAC,IAAI,EACL;MACA,MAAM,IAAI3B,KAAK,CAACpC,2BAA2B,CAAC;IAC9C;IAEA,IAAI,CAACgV,SAAS,GAAG,IAAIpU,QAAQ,CAAC,IAAI,CAAC0L,OAAO,CAACzL,IAAI,CAAC;IAEhD,IAAI,CAACoU,aAAa,CAACpP,IAAI,EAAEnD,KAAK,CAAC;EACjC;EAACjB,YAAA,CAAAsT,IAAA;IAAA5U,GAAA;IAAAvB,KAAA,EAED,SAAAqW,cAAcpP,IAAI,EAAEnD,KAAK,EAAE;MACzB,IAAI,CAACwS,KAAK,GAAGrP,IAAI;MAEjB,IAAInD,KAAK,IAAI,EAAEA,KAAK,YAAY4C,SAAS,CAAC,EAAE;QAC1C,MAAM,IAAIlD,KAAK,CAACnC,oBAAoB,CAAC;MACvC;MAEA,IAAI,CAACkV,QAAQ,GACXzS,KAAK,IACLgF,WAAW,CAAC,IAAI,CAAC4E,OAAO,CAACzL,IAAI,EAAE,IAAI,CAACqU,KAAK,EAAE;QACzCjT,KAAK,EAAE,IAAI,CAACqK,OAAO,CAACrK,KAAK;QACzBiC,eAAe,EAAE,IAAI,CAACoI,OAAO,CAACpI;MAChC,CAAC,CAAC;IACN;EAAC;IAAA/D,GAAA;IAAAvB,KAAA,EAED,SAAA4H,IAAIJ,GAAG,EAAE;MACP,IAAI,CAAC5G,SAAS,CAAC4G,GAAG,CAAC,EAAE;QACnB;MACF;MAEA,IAAI,CAAC8O,KAAK,CAAC3T,IAAI,CAAC6E,GAAG,CAAC;MACpB,IAAI,CAAC+O,QAAQ,CAAC3O,GAAG,CAACJ,GAAG,CAAC;IACxB;EAAC;IAAAjG,GAAA;IAAAvB,KAAA,EAED,SAAAwW,OAAA,EAA8C;MAAA,IAAvCC,SAAS,GAAA9Q,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAG,SAAC;QAAA,OAAmB,KAAK;MAAA;MAC1C,IAAMsM,OAAO,GAAG,EAAE;MAElB,KAAK,IAAIlO,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACsS,KAAK,CAACtV,MAAM,EAAE+C,CAAC,GAAGC,GAAG,EAAED,CAAC,IAAI,CAAC,EAAE;QACxD,IAAMyD,GAAG,GAAG,IAAI,CAAC8O,KAAK,CAACvS,CAAC,CAAC;QACzB,IAAI0S,SAAS,CAACjP,GAAG,EAAEzD,CAAC,CAAC,EAAE;UACrB,IAAI,CAAC+D,QAAQ,CAAC/D,CAAC,CAAC;UAChBA,CAAC,IAAI,CAAC;UACNC,GAAG,IAAI,CAAC;UAERiO,OAAO,CAACtP,IAAI,CAAC6E,GAAG,CAAC;QACnB;MACF;MAEA,OAAOyK,OAAO;IAChB;EAAC;IAAA1Q,GAAA;IAAAvB,KAAA,EAED,SAAA8H,SAASjD,GAAG,EAAE;MACZ,IAAI,CAACyR,KAAK,CAACvO,MAAM,CAAClD,GAAG,EAAE,CAAC,CAAC;MACzB,IAAI,CAAC0R,QAAQ,CAACzO,QAAQ,CAACjD,GAAG,CAAC;IAC7B;EAAC;IAAAtD,GAAA;IAAAvB,KAAA,EAED,SAAA0W,SAAA,EAAW;MACT,OAAO,IAAI,CAACH,QAAQ;IACtB;EAAC;IAAAhV,GAAA;IAAAvB,KAAA,EAED,SAAA6K,OAAOkH,KAAK,EAAuB;MAAA,IAAA4E,MAAA,GAAAhR,SAAA,CAAA3E,MAAA,QAAA2E,SAAA,QAAA9E,SAAA,GAAA8E,SAAA,MAAJ,CAAC,CAAC;QAAAiR,YAAA,GAAAD,MAAA,CAAjBE,KAAK;QAALA,KAAK,GAAAD,YAAA,cAAG,CAAC,CAAC,GAAAA,YAAA;MACxB,IAAAE,cAAA,GAMI,IAAI,CAACpJ,OAAO;QALdxJ,cAAc,GAAA4S,cAAA,CAAd5S,cAAc;QACdK,YAAY,GAAAuS,cAAA,CAAZvS,YAAY;QACZC,UAAU,GAAAsS,cAAA,CAAVtS,UAAU;QACVC,MAAM,GAAAqS,cAAA,CAANrS,MAAM;QACNY,eAAe,GAAAyR,cAAA,CAAfzR,eAAe;MAGjB,IAAI4M,OAAO,GAAG1R,QAAQ,CAACwR,KAAK,CAAC,GACzBxR,QAAQ,CAAC,IAAI,CAAC+V,KAAK,CAAC,CAAC,CAAC,CAAC,GACrB,IAAI,CAACS,iBAAiB,CAAChF,KAAK,CAAC,GAC7B,IAAI,CAACiF,iBAAiB,CAACjF,KAAK,CAAC,GAC/B,IAAI,CAACkF,cAAc,CAAClF,KAAK,CAAC;MAE9BqD,YAAY,CAACnD,OAAO,EAAE;QAAE5M,eAAe,EAAfA;MAAgB,CAAC,CAAC;MAE1C,IAAIb,UAAU,EAAE;QACdyN,OAAO,CAACiF,IAAI,CAACzS,MAAM,CAAC;MACtB;MAEA,IAAIjE,QAAQ,CAACqW,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,CAAC,EAAE;QACjC5E,OAAO,GAAGA,OAAO,CAACkF,KAAK,CAAC,CAAC,EAAEN,KAAK,CAAC;MACnC;MAEA,OAAOhB,MAAM,CAAC5D,OAAO,EAAE,IAAI,CAACqE,KAAK,EAAE;QACjCpS,cAAc,EAAdA,cAAc;QACdK,YAAY,EAAZA;MACF,CAAC,CAAC;IACJ;EAAC;IAAAhD,GAAA;IAAAvB,KAAA,EAED,SAAA+W,kBAAkBhF,KAAK,EAAE;MACvB,IAAMK,QAAQ,GAAG0B,cAAc,CAAC/B,KAAK,EAAE,IAAI,CAACrE,OAAO,CAAC;MACpD,IAAQxG,OAAO,GAAK,IAAI,CAACqP,QAAQ,CAAzBrP,OAAO;MACf,IAAM+K,OAAO,GAAG,EAAE;;MAElB;MACA/K,OAAO,CAAC3E,OAAO,CAAC,UAAA6U,MAAA,EAAkC;QAAA,IAA5BtM,IAAI,GAAAsM,MAAA,CAAPjP,CAAC;UAAWtD,GAAG,GAAAuS,MAAA,CAANrT,CAAC;UAAU2B,IAAI,GAAA0R,MAAA,CAAP/Q,CAAC;QACnC,IAAI,CAACzF,SAAS,CAACkK,IAAI,CAAC,EAAE;UACpB;QACF;QAEA,IAAAuM,kBAAA,GAAoCjF,QAAQ,CAAClE,QAAQ,CAACpD,IAAI,CAAC;UAAnD8B,OAAO,GAAAyK,kBAAA,CAAPzK,OAAO;UAAEhI,KAAK,GAAAyS,kBAAA,CAALzS,KAAK;UAAE6F,OAAO,GAAA4M,kBAAA,CAAP5M,OAAO;QAE/B,IAAImC,OAAO,EAAE;UACXqF,OAAO,CAACtP,IAAI,CAAC;YACXsF,IAAI,EAAE6C,IAAI;YACVjG,GAAG,EAAHA,GAAG;YACHqK,OAAO,EAAE,CAAC;cAAEtK,KAAK,EAALA,KAAK;cAAE5E,KAAK,EAAE8K,IAAI;cAAEpF,IAAI,EAAJA,IAAI;cAAE+E,OAAO,EAAPA;YAAQ,CAAC;UACjD,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MAEF,OAAOwH,OAAO;IAChB;EAAC;IAAA1Q,GAAA;IAAAvB,KAAA,EAED,SAAAiX,eAAelF,KAAK,EAAE;MAAA,IAAAuF,MAAA;MAEpB,IAAMC,UAAU,GAAG5C,KAAK,CAAC5C,KAAK,EAAE,IAAI,CAACrE,OAAO,CAAC;MAE7C,IAAM8J,QAAQ,GAAG,SAAXA,QAAQA,CAAIvC,IAAI,EAAEhN,IAAI,EAAEpD,GAAG,EAAK;QACpC,IAAI,CAACoQ,IAAI,CAACC,QAAQ,EAAE;UAClB,IAAQnS,KAAK,GAAekS,IAAI,CAAxBlS,KAAK;YAAEqP,QAAQ,GAAK6C,IAAI,CAAjB7C,QAAQ;UAEvB,IAAMlD,OAAO,GAAGoI,MAAI,CAACG,YAAY,CAAC;YAChClW,GAAG,EAAE+V,MAAI,CAAClB,SAAS,CAACtT,GAAG,CAACC,KAAK,CAAC;YAC9B/C,KAAK,EAAEsX,MAAI,CAACf,QAAQ,CAACvO,sBAAsB,CAACC,IAAI,EAAElF,KAAK,CAAC;YACxDqP,QAAQ,EAARA;UACF,CAAC,CAAC;UAEF,IAAIlD,OAAO,IAAIA,OAAO,CAAClO,MAAM,EAAE;YAC7B,OAAO,CACL;cACE6D,GAAG,EAAHA,GAAG;cACHoD,IAAI,EAAJA,IAAI;cACJiH,OAAO,EAAPA;YACF,CAAC,CACF;UACH;UAEA,OAAO,EAAE;QACX;QAEA,IAAMwI,GAAG,GAAG,EAAE;QACd,KAAK,IAAI3T,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGiR,IAAI,CAACC,QAAQ,CAAClU,MAAM,EAAE+C,CAAC,GAAGC,GAAG,EAAED,CAAC,IAAI,CAAC,EAAE;UAC3D,IAAM4T,KAAK,GAAG1C,IAAI,CAACC,QAAQ,CAACnR,CAAC,CAAC;UAC9B,IAAM1D,MAAM,GAAGmX,QAAQ,CAACG,KAAK,EAAE1P,IAAI,EAAEpD,GAAG,CAAC;UACzC,IAAIxE,MAAM,CAACW,MAAM,EAAE;YACjB0W,GAAG,CAAC/U,IAAI,CAAAkR,KAAA,CAAR6D,GAAG,EAAAhJ,kBAAA,CAASrO,MAAM,EAAC;UACrB,CAAC,MAAM,IAAI4U,IAAI,CAACE,QAAQ,KAAKnB,eAAe,CAACC,GAAG,EAAE;YAChD,OAAO,EAAE;UACX;QACF;QACA,OAAOyD,GAAG;MACZ,CAAC;MAED,IAAMxQ,OAAO,GAAG,IAAI,CAACqP,QAAQ,CAACrP,OAAO;MACrC,IAAM0Q,SAAS,GAAG,CAAC,CAAC;MACpB,IAAM3F,OAAO,GAAG,EAAE;MAElB/K,OAAO,CAAC3E,OAAO,CAAC,UAAAsV,MAAA,EAAyB;QAAA,IAAnB5P,IAAI,GAAA4P,MAAA,CAAPxP,CAAC;UAAWxD,GAAG,GAAAgT,MAAA,CAAN9T,CAAC;QAC3B,IAAInD,SAAS,CAACqH,IAAI,CAAC,EAAE;UACnB,IAAI6P,UAAU,GAAGN,QAAQ,CAACD,UAAU,EAAEtP,IAAI,EAAEpD,GAAG,CAAC;UAEhD,IAAIiT,UAAU,CAAC9W,MAAM,EAAE;YACrB;YACA,IAAI,CAAC4W,SAAS,CAAC/S,GAAG,CAAC,EAAE;cACnB+S,SAAS,CAAC/S,GAAG,CAAC,GAAG;gBAAEA,GAAG,EAAHA,GAAG;gBAAEoD,IAAI,EAAJA,IAAI;gBAAEiH,OAAO,EAAE;cAAG,CAAC;cAC3C+C,OAAO,CAACtP,IAAI,CAACiV,SAAS,CAAC/S,GAAG,CAAC,CAAC;YAC9B;YACAiT,UAAU,CAACvV,OAAO,CAAC,UAAAwV,MAAA,EAAiB;cAAA,IAAAC,qBAAA;cAAA,IAAd9I,OAAO,GAAA6I,MAAA,CAAP7I,OAAO;cAC3B,CAAA8I,qBAAA,GAAAJ,SAAS,CAAC/S,GAAG,CAAC,CAACqK,OAAO,EAACvM,IAAI,CAAAkR,KAAA,CAAAmE,qBAAA,EAAAtJ,kBAAA,CAAIQ,OAAO,EAAC;YACzC,CAAC,CAAC;UACJ;QACF;MACF,CAAC,CAAC;MAEF,OAAO+C,OAAO;IAChB;EAAC;IAAA1Q,GAAA;IAAAvB,KAAA,EAED,SAAAgX,kBAAkBjF,KAAK,EAAE;MAAA,IAAAkG,MAAA;MACvB,IAAM7F,QAAQ,GAAG0B,cAAc,CAAC/B,KAAK,EAAE,IAAI,CAACrE,OAAO,CAAC;MACpD,IAAAwK,cAAA,GAA0B,IAAI,CAAC3B,QAAQ;QAA/BtU,IAAI,GAAAiW,cAAA,CAAJjW,IAAI;QAAEiF,OAAO,GAAAgR,cAAA,CAAPhR,OAAO;MACrB,IAAM+K,OAAO,GAAG,EAAE;;MAElB;MACA/K,OAAO,CAAC3E,OAAO,CAAC,UAAA4V,MAAA,EAAyB;QAAA,IAAnBlQ,IAAI,GAAAkQ,MAAA,CAAP9P,CAAC;UAAWxD,GAAG,GAAAsT,MAAA,CAANpU,CAAC;QAC3B,IAAI,CAACnD,SAAS,CAACqH,IAAI,CAAC,EAAE;UACpB;QACF;QAEA,IAAIiH,OAAO,GAAG,EAAE;;QAEhB;QACAjN,IAAI,CAACM,OAAO,CAAC,UAAChB,GAAG,EAAE+G,QAAQ,EAAK;UAC9B4G,OAAO,CAACvM,IAAI,CAAAkR,KAAA,CAAZ3E,OAAO,EAAAR,kBAAA,CACFuJ,MAAI,CAACR,YAAY,CAAC;YACnBlW,GAAG,EAAHA,GAAG;YACHvB,KAAK,EAAEiI,IAAI,CAACK,QAAQ,CAAC;YACrB8J,QAAQ,EAARA;UACF,CAAC,CAAC,CACJ,CAAC;QACH,CAAC,CAAC;QAEF,IAAIlD,OAAO,CAAClO,MAAM,EAAE;UAClBiR,OAAO,CAACtP,IAAI,CAAC;YACXkC,GAAG,EAAHA,GAAG;YACHoD,IAAI,EAAJA,IAAI;YACJiH,OAAO,EAAPA;UACF,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MAEF,OAAO+C,OAAO;IAChB;EAAC;IAAA1Q,GAAA;IAAAvB,KAAA,EACD,SAAAyX,aAAAW,MAAA,EAAuC;MAAA,IAAxB7W,GAAG,GAAA6W,MAAA,CAAH7W,GAAG;QAAEvB,KAAK,GAAAoY,MAAA,CAALpY,KAAK;QAAEoS,QAAQ,GAAAgG,MAAA,CAARhG,QAAQ;MACjC,IAAI,CAACxR,SAAS,CAACZ,KAAK,CAAC,EAAE;QACrB,OAAO,EAAE;MACX;MAEA,IAAIkP,OAAO,GAAG,EAAE;MAEhB,IAAInP,OAAO,CAACC,KAAK,CAAC,EAAE;QAClBA,KAAK,CAACuC,OAAO,CAAC,UAAA8V,MAAA,EAAkC;UAAA,IAA5BvN,IAAI,GAAAuN,MAAA,CAAPlQ,CAAC;YAAWtD,GAAG,GAAAwT,MAAA,CAANtU,CAAC;YAAU2B,IAAI,GAAA2S,MAAA,CAAPhS,CAAC;UACjC,IAAI,CAACzF,SAAS,CAACkK,IAAI,CAAC,EAAE;YACpB;UACF;UAEA,IAAAwN,mBAAA,GAAoClG,QAAQ,CAAClE,QAAQ,CAACpD,IAAI,CAAC;YAAnD8B,OAAO,GAAA0L,mBAAA,CAAP1L,OAAO;YAAEhI,KAAK,GAAA0T,mBAAA,CAAL1T,KAAK;YAAE6F,OAAO,GAAA6N,mBAAA,CAAP7N,OAAO;UAE/B,IAAImC,OAAO,EAAE;YACXsC,OAAO,CAACvM,IAAI,CAAC;cACXiC,KAAK,EAALA,KAAK;cACLrD,GAAG,EAAHA,GAAG;cACHvB,KAAK,EAAE8K,IAAI;cACXjG,GAAG,EAAHA,GAAG;cACHa,IAAI,EAAJA,IAAI;cACJ+E,OAAO,EAAPA;YACF,CAAC,CAAC;UACJ;QACF,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,IAAWK,IAAI,GAAc9K,KAAK,CAA1BmI,CAAC;UAAWzC,KAAI,GAAK1F,KAAK,CAAjBqG,CAAC;QAElB,IAAAkS,mBAAA,GAAoCnG,QAAQ,CAAClE,QAAQ,CAACpD,IAAI,CAAC;UAAnD8B,OAAO,GAAA2L,mBAAA,CAAP3L,OAAO;UAAEhI,KAAK,GAAA2T,mBAAA,CAAL3T,KAAK;UAAE6F,OAAO,GAAA8N,mBAAA,CAAP9N,OAAO;QAE/B,IAAImC,OAAO,EAAE;UACXsC,OAAO,CAACvM,IAAI,CAAC;YAAEiC,KAAK,EAALA,KAAK;YAAErD,GAAG,EAAHA,GAAG;YAAEvB,KAAK,EAAE8K,IAAI;YAAEpF,IAAI,EAAJA,KAAI;YAAE+E,OAAO,EAAPA;UAAQ,CAAC,CAAC;QAC1D;MACF;MAEA,OAAOyE,OAAO;IAChB;EAAC;EAAA,OAAAiH,IAAA;AAAA;AAGHA,IAAI,CAACqC,OAAO,GAAG,OAAO;AACtBrC,IAAI,CAACrN,WAAW,GAAGA,WAAW;AAC9BqN,IAAI,CAAC/M,UAAU,GAAGA,UAAU;AAC5B+M,IAAI,CAACsC,MAAM,GAAGlT,MAAM;AAEpB;EACE4Q,IAAI,CAACrE,UAAU,GAAG6C,KAAK;AACzB;AAEA;EACEf,QAAQ,CAACnB,cAAc,CAAC;AAC1B;AAEA,SAAS0D,IAAI,IAAIuC,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}